#!/usr/bin/env bash
# This script was generated by bashly 1.3.1 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
monk_usage() {
  printf "monk - Monk CLI - Command-line interface for PaaS Backend API\n\n"

  printf "%s\n" "Usage:"
  printf "  monk COMMAND\n"
  printf "  monk [COMMAND] --help | -h\n"
  printf "  monk --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Authentication and token management\n" "auth   "
  printf "  %s   Data operations on dynamic schemas\n" "data   "
  printf "  %s   Schema and metadata management\n" "meta   "
  printf "  %s   Advanced search with filter DSL\n" "find   "
  printf "  %s   Server connectivity testing\n" "ping   "
  printf "  %s   External git-based test management\n" "test   "
  printf "  %s   Remote server management\n" "servers"
  printf "  %s   Multi-tenant database management\n" "tenant "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "CLI_VERBOSE"
    printf "    Enable verbose output for all commands\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "JWT_TOKEN"
    printf "    Authentication token (managed by monk auth)\n"
    echo

  fi
}

# :command.usage
monk_auth_usage() {
  printf "monk auth - Authentication and token management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth COMMAND\n"
  printf "  monk auth [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Authenticate with tenant and username\n" "login "
  printf "  %s   Clear stored JWT token\n" "logout"
  printf "  %s   Show authentication status\n" "status"
  printf "  %s   Display current JWT token\n" "token "
  printf "  %s   Decode and display JWT token contents\n" "info  "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_login_usage() {
  printf "monk auth login - Authenticate with tenant and username\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth login TENANT USERNAME\n"
  printf "  monk auth login --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TENANT"
    printf "    Tenant name for authentication\n"
    echo

    # :argument.usage
    printf "  %s\n" "USERNAME"
    printf "    Username for authentication\n"
    echo

  fi
}

# :command.usage
monk_auth_logout_usage() {
  printf "monk auth logout - Clear stored JWT token\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth logout\n"
  printf "  monk auth logout --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_status_usage() {
  printf "monk auth status - Show authentication status\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth status\n"
  printf "  monk auth status --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_token_usage() {
  printf "monk auth token - Display current JWT token\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth token\n"
  printf "  monk auth token --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_info_usage() {
  printf "monk auth info - Decode and display JWT token contents\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth info\n"
  printf "  monk auth info --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_data_usage() {
  printf "monk data - Data operations on dynamic schemas\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data COMMAND\n"
  printf "  monk data [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   List all records for schema\n" "list  "
  printf "  %s   Get specific record\n" "get   "
  printf "  %s   Create record from stdin\n" "create"
  printf "  %s   Update record from stdin\n" "update"
  printf "  %s   Delete record\n" "delete"
  printf "  %s   Export records to JSON files\n" "export"
  printf "  %s   Import JSON files as records\n" "import"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_data_list_usage() {
  printf "monk data list - List all records for schema\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data list SCHEMA\n"
  printf "  monk data list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to list records from\n"
    echo

  fi
}

# :command.usage
monk_data_get_usage() {
  printf "monk data get - Get specific record\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data get SCHEMA ID\n"
  printf "  monk data get --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name\n"
    echo

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    Record ID to retrieve\n"
    echo

  fi
}

# :command.usage
monk_data_create_usage() {
  printf "monk data create - Create record from stdin\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data create SCHEMA\n"
  printf "  monk data create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to create record in\n"
    echo

  fi
}

# :command.usage
monk_data_update_usage() {
  printf "monk data update - Update record from stdin\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data update SCHEMA ID\n"
  printf "  monk data update --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name\n"
    echo

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    Record ID to update\n"
    echo

  fi
}

# :command.usage
monk_data_delete_usage() {
  printf "monk data delete - Delete record\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data delete SCHEMA ID\n"
  printf "  monk data delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name\n"
    echo

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    Record ID to delete\n"
    echo

  fi
}

# :command.usage
monk_data_export_usage() {
  printf "monk data export - Export records to JSON files\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data export SCHEMA DIR\n"
  printf "  monk data export --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to export\n"
    echo

    # :argument.usage
    printf "  %s\n" "DIR"
    printf "    Directory to export to\n"
    echo

  fi
}

# :command.usage
monk_data_import_usage() {
  printf "monk data import - Import JSON files as records\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data import SCHEMA DIR\n"
  printf "  monk data import --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to import into\n"
    echo

    # :argument.usage
    printf "  %s\n" "DIR"
    printf "    Directory to import from\n"
    echo

  fi
}

# :command.usage
monk_meta_usage() {
  printf "monk meta - Schema and metadata management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk meta COMMAND\n"
  printf "  monk meta [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   List all schemas\n" "list  "
  printf "  %s   Get specific schema\n" "get   "
  printf "  %s   Create schema from stdin (YAML/JSON)\n" "create"
  printf "  %s   Update schema from stdin\n" "update"
  printf "  %s   Delete schema\n" "delete"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_meta_list_usage() {
  printf "monk meta list - List all schemas\n\n"

  printf "%s\n" "Usage:"
  printf "  monk meta list [TYPE]\n"
  printf "  monk meta list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TYPE"
    printf "    Type to list\n"
    printf "    %s\n" "Default: schema"
    echo

  fi
}

# :command.usage
monk_meta_get_usage() {
  printf "monk meta get - Get specific schema\n\n"

  printf "%s\n" "Usage:"
  printf "  monk meta get TYPE NAME\n"
  printf "  monk meta get --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TYPE"
    printf "    Type to get\n"
    echo

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Schema name to retrieve\n"
    echo

  fi
}

# :command.usage
monk_meta_create_usage() {
  printf "monk meta create - Create schema from stdin (YAML/JSON)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk meta create TYPE\n"
  printf "  monk meta create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TYPE"
    printf "    Type to create\n"
    echo

  fi
}

# :command.usage
monk_meta_update_usage() {
  printf "monk meta update - Update schema from stdin\n\n"

  printf "%s\n" "Usage:"
  printf "  monk meta update TYPE NAME\n"
  printf "  monk meta update --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TYPE"
    printf "    Type to update\n"
    echo

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Schema name to update\n"
    echo

  fi
}

# :command.usage
monk_meta_delete_usage() {
  printf "monk meta delete - Delete schema\n\n"

  printf "%s\n" "Usage:"
  printf "  monk meta delete TYPE NAME\n"
  printf "  monk meta delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TYPE"
    printf "    Type to delete\n"
    echo

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Schema name to delete\n"
    echo

  fi
}

# :command.usage
monk_find_usage() {
  printf "monk find - Advanced search with filter DSL\n\n"

  printf "%s\n" "Usage:"
  printf "  monk find SCHEMA [OPTIONS]\n"
  printf "  monk find --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--field, -f FIELD"
    printf "    Extract specific field from results\n"
    echo

    # :flag.usage
    printf "  %s\n" "--count, -c"
    printf "    Return count of matching records only\n"
    echo

    # :flag.usage
    printf "  %s\n" "--exit-code, -x"
    printf "    Exit with code only (no output)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--verbose, -v"
    printf "    Verbose output\n"
    echo

    # :flag.usage
    printf "  %s\n" "--head, -H"
    printf "    Return only first record\n"
    echo

    # :flag.usage
    printf "  %s\n" "--tail, -T"
    printf "    Return only last record\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema to search\n"
    echo

  fi
}

# :command.usage
monk_ping_usage() {
  printf "monk ping - Server connectivity testing\n\n"

  printf "%s\n" "Usage:"
  printf "  monk ping [OPTIONS]\n"
  printf "  monk ping --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--verbose, -v"
    printf "    Verbose server information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--jwt-token, -j TOKEN"
    printf "    Include JWT token in request\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_test_usage() {
  printf "monk test - External git-based test management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk test COMMAND\n"
  printf "  monk test [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Create/update git-aware test environment\n" "git "
  printf "  %s   Compare test results between environments\n" "diff"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_test_git_usage() {
  printf "monk test git - Create/update git-aware test environment\n\n"

  printf "%s\n" "Usage:"
  printf "  monk test git BRANCH [COMMIT] [OPTIONS]\n"
  printf "  monk test git --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--clean"
    printf "    Force clean build by removing existing environment\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "BRANCH"
    printf "    Git branch or reference\n"
    echo

    # :argument.usage
    printf "  %s\n" "COMMIT"
    printf "    Specific commit (optional)\n"
    echo

  fi
}

# :command.usage
monk_test_diff_usage() {
  printf "monk test diff - Compare test results between environments\n\n"

  printf "%s\n" "Usage:"
  printf "  monk test diff RUN1 RUN2\n"
  printf "  monk test diff --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "RUN1"
    printf "    First test run to compare\n"
    echo

    # :argument.usage
    printf "  %s\n" "RUN2"
    printf "    Second test run to compare\n"
    echo

  fi
}

# :command.usage
monk_servers_usage() {
  printf "monk servers - Remote server management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk servers COMMAND\n"
  printf "  monk servers [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Register remote server\n" "add     "
  printf "  %s   List all servers with health status\n" "list    "
  printf "  %s   Show currently selected server\n" "current "
  printf "  %s   Switch to server (persistent selection) or show current server\n" "use     "
  printf "  %s   Remove server from registry\n" "delete  "
  printf "  %s   Health check specific server\n" "ping    "
  printf "  %s   Health check all registered servers\n" "ping-all"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_servers_add_usage() {
  printf "monk servers add - Register remote server\n\n"

  printf "%s\n" "Usage:"
  printf "  monk servers add NAME ENDPOINT [OPTIONS]\n"
  printf "  monk servers add --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--description DESCRIPTION"
    printf "    Optional server description\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name\n"
    echo

    # :argument.usage
    printf "  %s\n" "ENDPOINT"
    printf "    Server endpoint (host:port)\n"
    echo

  fi
}

# :command.usage
monk_servers_list_usage() {
  printf "monk servers list - List all servers with health status\n\n"

  printf "%s\n" "Usage:"
  printf "  monk servers list\n"
  printf "  monk servers list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_servers_current_usage() {
  printf "monk servers current - Show currently selected server\n\n"

  printf "%s\n" "Usage:"
  printf "  monk servers current\n"
  printf "  monk servers current --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_servers_use_usage() {
  printf "monk servers use - Switch to server (persistent selection) or show current server\n\n"

  printf "%s\n" "Usage:"
  printf "  monk servers use [NAME]\n"
  printf "  monk servers use --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name to switch to (omit to show current server)\n"
    echo

  fi
}

# :command.usage
monk_servers_delete_usage() {
  printf "monk servers delete - Remove server from registry\n\n"

  printf "%s\n" "Usage:"
  printf "  monk servers delete NAME\n"
  printf "  monk servers delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name to delete\n"
    echo

  fi
}

# :command.usage
monk_servers_ping_usage() {
  printf "monk servers ping - Health check specific server\n\n"

  printf "%s\n" "Usage:"
  printf "  monk servers ping NAME\n"
  printf "  monk servers ping --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name to ping\n"
    echo

  fi
}

# :command.usage
monk_servers_ping_all_usage() {
  printf "monk servers ping-all - Health check all registered servers\n\n"

  printf "%s\n" "Usage:"
  printf "  monk servers ping-all\n"
  printf "  monk servers ping-all --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_tenant_usage() {
  printf "monk tenant - Multi-tenant database management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant COMMAND\n"
  printf "  monk tenant [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Create new tenant database and record\n" "create"
  printf "  %s   Delete tenant database\n" "delete"
  printf "  %s   Truncate and re-initialize tenant database\n" "init  "
  printf "  %s   List all tenant databases\n" "list  "
  printf "  %s   Switch to tenant database\n" "use   "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_tenant_create_usage() {
  printf "monk tenant create - Create new tenant database and record\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant create NAME [OPTIONS]\n"
  printf "  monk tenant create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--host HOST"
    printf "    Database host\n"
    printf "    %s\n" "Default: localhost"
    echo

    # :flag.usage
    printf "  %s\n" "--force, -f"
    printf "    Force creation by dropping existing database if it exists\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Name of the tenant database to create\n"
    echo

  fi
}

# :command.usage
monk_tenant_delete_usage() {
  printf "monk tenant delete - Delete tenant database\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant delete NAME\n"
  printf "  monk tenant delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Name of the tenant database to delete\n"
    echo

  fi
}

# :command.usage
monk_tenant_init_usage() {
  printf "monk tenant init - Truncate and re-initialize tenant database\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant init NAME\n"
  printf "  monk tenant init --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Name of the existing tenant database to re-initialize\n"
    echo

  fi
}

# :command.usage
monk_tenant_list_usage() {
  printf "monk tenant list - List all tenant databases\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant list\n"
  printf "  monk tenant list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_tenant_use_usage() {
  printf "monk tenant use - Switch to tenant database\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant use NAME\n"
  printf "  monk tenant use --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Name of the tenant to switch to\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/common.sh
#!/bin/bash

# Common functions for bashly CLI commands
# This file contains shared functionality migrated from cli/common.sh

# JWT token storage file
JWT_TOKEN_FILE="${HOME}/.monk-jwt-token"

# Servers configuration file
SERVERS_CONFIG="${HOME}/.config/monk/servers.json"

# Default configuration
DEFAULT_BASE_URL="http://localhost:3000"
DEFAULT_LIMIT=50
DEFAULT_FORMAT="raw"

# Colors for output formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print colored output
print_error() {
    echo -e "${RED}✗ $1${NC}" >&2
}

print_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

print_info() {
    echo -e "${YELLOW}ℹ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠ $1${NC}"
}

# Get base URL from servers config - fail if not configured
get_base_url() {
    local servers_config="${HOME}/.config/monk/servers.json"

    # Check if jq is available
    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required for server configuration" >&2
        echo "Install jq to use server configuration" >&2
        exit 1
    fi

    # Check if config file exists
    if [[ ! -f "$servers_config" ]]; then
        echo "Error: No server configuration found" >&2
        echo "Use 'monk servers add <name> <hostname:port>' to add a server" >&2
        exit 1
    fi

    # Get current server
    local current_server
    current_server=$(jq -r '.current // empty' "$servers_config" 2>/dev/null)

    if [[ -z "$current_server" || "$current_server" == "null" ]]; then
        echo "Error: No current server selected" >&2
        echo "Use 'monk servers use <name>' to select a server" >&2
        exit 1
    fi

    # Get server info
    local server_info
    server_info=$(jq -r ".servers.\"$current_server\"" "$servers_config" 2>/dev/null)

    if [[ "$server_info" == "null" ]]; then
        echo "Error: Current server '$current_server' not found in configuration" >&2
        echo "Use 'monk servers list' to see available servers" >&2
        exit 1
    fi

    # Extract connection details
    local hostname=$(echo "$server_info" | jq -r '.hostname')
    local port=$(echo "$server_info" | jq -r '.port')
    local protocol=$(echo "$server_info" | jq -r '.protocol')

    # Validate required fields
    if [[ "$hostname" == "null" || "$port" == "null" || "$protocol" == "null" ]]; then
        echo "Error: Invalid server configuration for '$current_server'" >&2
        echo "Server configuration is missing required fields (hostname, port, protocol)" >&2
        exit 1
    fi

    echo "$protocol://$hostname:$port"
}

# Get stored JWT token for current server
get_jwt_token() {
    init_servers_config

    if ! command -v jq >/dev/null 2>&1; then
        # Fallback to old global token file if jq not available
        if [ -f "$JWT_TOKEN_FILE" ]; then
            cat "$JWT_TOKEN_FILE"
        fi
        return
    fi

    # Get current server name
    local current_server
    current_server=$(jq -r '.current // empty' "$SERVERS_CONFIG" 2>/dev/null)

    if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
        # No current server, try fallback to global token
        if [ -f "$JWT_TOKEN_FILE" ]; then
            cat "$JWT_TOKEN_FILE"
        fi
        return
    fi

    # Get server-specific token
    local token
    token=$(jq -r ".servers.\"$current_server\".jwt_token // empty" "$SERVERS_CONFIG" 2>/dev/null)

    if [ -n "$token" ] && [ "$token" != "null" ]; then
        echo "$token"
    fi
}

# Store JWT token for current server
store_token() {
    local token="$1"

    init_servers_config

    if ! command -v jq >/dev/null 2>&1; then
        # Fallback to old global token file if jq not available
        echo "$token" > "$JWT_TOKEN_FILE"
        chmod 600 "$JWT_TOKEN_FILE"
        return
    fi

    # Get current server name
    local current_server
    current_server=$(jq -r '.current // empty' "$SERVERS_CONFIG" 2>/dev/null)

    if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
        # No current server, store in global file as fallback
        echo "$token" > "$JWT_TOKEN_FILE"
        chmod 600 "$JWT_TOKEN_FILE"
        return
    fi

    # Store token in server configuration
    local temp_file=$(mktemp)
    jq --arg server "$current_server" \
       --arg token "$token" \
       '.servers[$server].jwt_token = $token' \
       "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"

    # Set secure permissions on config file
    chmod 600 "$SERVERS_CONFIG"
}

# Remove stored JWT token for current server
remove_stored_token() {
    init_servers_config

    if ! command -v jq >/dev/null 2>&1; then
        # Fallback to old global token file if jq not available
        rm -f "$JWT_TOKEN_FILE"
        return
    fi

    # Get current server name
    local current_server
    current_server=$(jq -r '.current // empty' "$SERVERS_CONFIG" 2>/dev/null)

    if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
        # No current server, remove global file as fallback
        rm -f "$JWT_TOKEN_FILE"
        return
    fi

    # Remove token from server configuration
    local temp_file=$(mktemp)
    jq --arg server "$current_server" \
       'del(.servers[$server].jwt_token)' \
       "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"
}

# Make HTTP request and handle response - programmatic by default
make_request() {
    local method="$1"
    local url="$2"
    local data="$3"
    local base_url=$(get_base_url)
    local full_url="${base_url}${url}"

    # Only show verbose info if CLI_VERBOSE is set
    if [ "$CLI_VERBOSE" = "true" ]; then
        print_info "Making $method request to: $full_url" >&2
    fi

    local curl_args=(-s -X "$method" -H "Content-Type: application/json")

    # Add JWT token if available (unless it's an auth request)
    if [[ "$url" != "/auth/"* ]]; then
        local jwt_token
        jwt_token=$(get_jwt_token)
        if [ -n "$jwt_token" ]; then
            curl_args+=(-H "Authorization: Bearer $jwt_token")
            if [ "$CLI_VERBOSE" = "true" ]; then
                print_info "Using stored JWT token" >&2
            fi
        fi
    fi

    if [ -n "$data" ]; then
        curl_args+=(-d "$data")
    fi

    local response
    local http_code

    # Make request and capture both response and HTTP status code
    response=$(curl "${curl_args[@]}" -w "\n%{http_code}" "$full_url")
    http_code=$(echo "$response" | tail -n1)
    response=$(echo "$response" | sed '$d')

    # Handle HTTP errors
    case "$http_code" in
        200|201)
            if [ "$CLI_VERBOSE" = "true" ]; then
                print_success "Success ($http_code)" >&2
            fi
            # Return response without formatting - let caller handle it
            echo "$response"
            return 0
            ;;
        400|404|500)
            if [ "$CLI_VERBOSE" = "true" ]; then
                print_error "HTTP Error ($http_code)" >&2
            fi
            echo "$response" >&2
            exit 1
            ;;
        *)
            if [ "$CLI_VERBOSE" = "true" ]; then
                print_error "HTTP $http_code" >&2
            fi
            echo "$response" >&2
            exit 1
            ;;
    esac
}

# Handle response based on CLI flags - optimized for testing
handle_response() {
    local response="$1"
    local operation_type="$2"  # "list", "create", "get", etc.

    # Exit code only mode - no output, just exit status
    if [ "$CLI_EXIT_CODE_ONLY" = "true" ]; then
        if echo "$response" | grep -q '"success":true'; then
            exit 0
        else
            exit 1
        fi
    fi

    # Count mode for list operations
    if [ "$CLI_COUNT_MODE" = "true" ] && [ "$operation_type" = "list" ]; then
        if [ "$JSON_PARSER" = "jq" ]; then
            echo "$response" | jq '.data | length' 2>/dev/null || echo "0"
        elif [ "$JSON_PARSER" = "jshon" ]; then
            echo "$response" | jshon -e data -l 2>/dev/null || echo "0"
        else
            echo "$response"
        fi
        return
    fi

    # Field extraction mode
    if [ -n "$CLI_FORMAT" ]; then
        if [ "$JSON_PARSER" = "jq" ]; then
            # Handle both single objects and arrays
            if echo "$response" | jq -e '.data | type == "array"' >/dev/null 2>&1; then
                # Array case - extract field from each item
                echo "$response" | jq -r ".data[].${CLI_FORMAT}" 2>/dev/null || {
                    if [ "$CLI_VERBOSE" = "true" ]; then
                        print_error "Failed to extract field: $CLI_FORMAT" >&2
                    fi
                    exit 1
                }
            else
                # Single object case - extract field directly
                echo "$response" | jq -r ".data.${CLI_FORMAT}" 2>/dev/null || {
                    if [ "$CLI_VERBOSE" = "true" ]; then
                        print_error "Failed to extract field: $CLI_FORMAT" >&2
                    fi
                    exit 1
                }
            fi
        elif [ "$JSON_PARSER" = "jshon" ]; then
            echo "$response" | jshon -e data -e "$CLI_FORMAT" -u 2>/dev/null || {
                if [ "$CLI_VERBOSE" = "true" ]; then
                    print_error "Failed to extract field: $CLI_FORMAT" >&2
                fi
                exit 1
            }
        else
            if [ "$CLI_VERBOSE" = "true" ]; then
                print_error "jq or jshon required for field extraction" >&2
            fi
            exit 1
        fi
        return
    fi

    # Default: auto-extract 'data' property for cleaner output
    if [ "$JSON_PARSER" = "jq" ]; then
        # Check if response has success:true and extract data
        if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
            if echo "$response" | jq -e '.success == true' >/dev/null 2>&1; then
                # Success response - extract data
                echo "$response" | jq '.data'
            else
                # Error response - show full response for debugging
                echo "$response"
            fi
        else
            # Not a standard API response - show raw
            echo "$response"
        fi
    elif [ "$JSON_PARSER" = "jshon" ]; then
        # Check if response has success:true and extract data
        if echo "$response" | jshon -e success -u 2>/dev/null | grep -q "true"; then
            echo "$response" | jshon -e data 2>/dev/null || echo "$response"
        else
            echo "$response"
        fi
    else
        # No JSON parser - raw output
        echo "$response"
    fi
}

# Validate required arguments
require_args() {
    local required_count="$1"
    local actual_count="$2"
    local usage="$3"

    if [ "$actual_count" -lt "$required_count" ]; then
        print_error "Missing required arguments"
        print_info "Usage: $usage"
        exit 1
    fi
}

# Check dependencies - keep it simple
check_dependencies() {
    if ! command -v curl &> /dev/null; then
        print_error "curl is required but not installed."
        exit 1
    fi

    # Check for JSON parser for extraction operations (prefer jq over jshon)
    if command -v jq &> /dev/null; then
        export JSON_PARSER="jq"
    elif command -v jshon &> /dev/null; then
        export JSON_PARSER="jshon"
    else
        export JSON_PARSER="none"
    fi
}

# Initialize servers config if it doesn't exist
init_servers_config() {
    # Ensure config directory exists
    mkdir -p "$(dirname "$SERVERS_CONFIG")"

    if [ ! -f "$SERVERS_CONFIG" ]; then
        cat > "$SERVERS_CONFIG" << 'EOF'
{
  "servers": {},
  "current": null
}
EOF
    fi
}

# Parse hostname:port into components
parse_endpoint() {
    local endpoint="$1"
    local hostname=""
    local port=""
    local protocol=""

    # Handle protocol prefixes
    if echo "$endpoint" | grep -q "^https://"; then
        protocol="https"
        endpoint=$(echo "$endpoint" | sed 's|^https://||')
    elif echo "$endpoint" | grep -q "^http://"; then
        protocol="http"
        endpoint=$(echo "$endpoint" | sed 's|^http://||')
    fi

    # Parse hostname:port
    if echo "$endpoint" | grep -q ":"; then
        hostname=$(echo "$endpoint" | cut -d':' -f1)
        port=$(echo "$endpoint" | cut -d':' -f2)
    else
        hostname="$endpoint"
        port="80"
    fi

    # Auto-detect protocol if not specified
    if [ -z "$protocol" ]; then
        if [ "$port" = "443" ]; then
            protocol="https"
        else
            protocol="http"
        fi
    fi

    echo "$protocol|$hostname|$port"
}

# Health check a server URL
ping_server_url() {
    local base_url="$1"
    local timeout="${2:-5}"

    # Try to ping the /ping endpoint with a short timeout
    if curl -s --max-time "$timeout" --fail "$base_url/ping" >/dev/null 2>&1; then
        return 0
    elif curl -s --max-time "$timeout" --fail "$base_url/" >/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# Initialize tenant database schema
init_tenant_schema() {
    local tenant_name="$1"
    local db_user="${2:-$(whoami)}"

    # Find the schema file relative to the CLI root
    local schema_file=""

    # Try different possible locations for the schema file
    if [ -f "../sql/init-tenant.sql" ]; then
        schema_file="../sql/init-tenant.sql"
    elif [ -f "../../sql/init-tenant.sql" ]; then
        schema_file="../../sql/init-tenant.sql"
    elif [ -f "sql/init-tenant.sql" ]; then
        schema_file="sql/init-tenant.sql"
    else
        print_error "Schema file not found: init-tenant.sql"
        return 1
    fi

    print_info "Initializing tenant database schema..."
    if psql -U "$db_user" -d "$tenant_name" -f "$schema_file" >/dev/null 2>&1; then
        print_success "Tenant database schema initialized"
        return 0
    else
        print_error "Failed to initialize tenant database schema"
        return 1
    fi
}

# Validate schema exists (best effort)
validate_schema() {
    local schema="$1"

    # Don't validate if running in non-verbose mode for speed
    if [ "$CLI_VERBOSE" != "true" ]; then
        return 0
    fi

    # Try to get schema info - if it fails, just warn but continue
    local response
    if response=$(make_request "GET" "/api/meta/schema" "" 2>/dev/null); then
        if echo "$response" | grep -q "\"$schema\""; then
            if [ "$CLI_VERBOSE" = "true" ]; then
                print_info "Schema validated: $schema"
            fi
        else
            print_warning "Schema '$schema' not found in meta API, but continuing anyway"
        fi
    else
        if [ "$CLI_VERBOSE" = "true" ]; then
            print_info "Could not validate schema dynamically, assuming valid: $schema"
        fi
    fi
}

# :command.command_functions

# :command.function
monk_auth_login_command() {

  # src/auth_login_command.sh
  # Check dependencies
  check_dependencies

  # Extract tenant and username from bashly args
  tenant="${args[tenant]}"
  username="${args[username]}"

  if [ "$CLI_VERBOSE" = "true" ]; then
      print_info "Authenticating with tenant: $tenant, username: $username"
  fi

  # Prepare authentication request
  auth_data="{\"tenant\": \"$tenant\", \"username\": \"$username\"}"
  base_url=$(get_base_url)

  if [ "$CLI_VERBOSE" = "true" ]; then
      print_info "Sending authentication request to: ${base_url}/auth/login"
  fi

  # Make authentication request
  if response=$(make_request "POST" "/auth/login" "$auth_data"); then
      # Extract token from response
      token=""
      if [ "$JSON_PARSER" = "jq" ]; then
          token=$(echo "$response" | jq -r '.data.token' 2>/dev/null)
      elif [ "$JSON_PARSER" = "jshon" ]; then
          token=$(echo "$response" | jshon -e data -e token -u 2>/dev/null)
      else
          # Fallback: extract token manually
          token=$(echo "$response" | grep -o '"token":"[^"]*"' | cut -d'"' -f4)
      fi

      if [ -n "$token" ] && [ "$token" != "null" ]; then
          # Store token
          store_token "$token"

          print_success "Authentication successful"

          if [ "$CLI_VERBOSE" = "true" ]; then
              print_info "JWT token stored in: $JWT_TOKEN_FILE"
          fi
      else
          print_error "Failed to extract JWT token from response"
          if [ "$CLI_VERBOSE" = "true" ]; then
              print_info "Response: $response"
          fi
          exit 1
      fi
  else
      print_error "Authentication failed"
      exit 1
  fi
}

# :command.function
monk_auth_logout_command() {

  # src/auth_logout_command.sh
  if [ -f "$JWT_TOKEN_FILE" ]; then
      remove_stored_token
      print_success "Logged out successfully"
  else
      print_info "Already logged out"
  fi
}

# :command.function
monk_auth_status_command() {

  # src/auth_status_command.sh
  token=$(get_jwt_token)

  if [ -n "$token" ]; then
      print_success "Authenticated"

      # Try to extract domain from token (basic decode)
      if [ "$JSON_PARSER" = "jq" ] || [ "$JSON_PARSER" = "jshon" ]; then
          # Decode JWT payload (basic base64 decode of middle part)
          payload=$(echo "$token" | cut -d'.' -f2)
          # Add padding if needed
          case $((${#payload} % 4)) in
              2) payload="${payload}==" ;;
              3) payload="${payload}=" ;;
          esac

          if command -v base64 &> /dev/null; then
              decoded=$(echo "$payload" | base64 -d 2>/dev/null || echo "")
              if [ -n "$decoded" ]; then
                  if [ "$JSON_PARSER" = "jq" ]; then
                      domain=$(echo "$decoded" | jq -r '.domain' 2>/dev/null || echo "unknown")
                      exp=$(echo "$decoded" | jq -r '.exp' 2>/dev/null || echo "unknown")
                  elif [ "$JSON_PARSER" = "jshon" ]; then
                      domain=$(echo "$decoded" | jshon -e domain -u 2>/dev/null || echo "unknown")
                      exp=$(echo "$decoded" | jshon -e exp -u 2>/dev/null || echo "unknown")
                  fi

                  echo "Domain: $domain"
                  if [ "$exp" != "unknown" ] && [ "$exp" != "null" ]; then
                      if command -v date &> /dev/null; then
                          exp_date=$(date -r "$exp" 2>/dev/null || echo "unknown")
                          echo "Expires: $exp_date"
                      fi
                  fi
              fi
          fi
      fi

      echo "Token file: $JWT_TOKEN_FILE"
  else
      print_info "Not authenticated"
      echo "Use 'monk auth login --domain DOMAIN' to authenticate"
  fi
}

# :command.function
monk_auth_token_command() {

  # src/auth_token_command.sh
  token=$(get_jwt_token)

  if [ -n "$token" ]; then
      echo "$token"
  else
      print_error "No token found. Use 'monk auth login --domain DOMAIN' first"
      exit 1
  fi
}

# :command.function
monk_auth_info_command() {

  # src/auth_info_command.sh
  token=$(get_jwt_token)

  if [ -z "$token" ]; then
      print_error "No authentication token found"
      print_info "Use 'monk auth login --domain DOMAIN' to authenticate"
      exit 1
  fi

  # Extract payload (second part) from JWT
  payload=$(echo "$token" | cut -d'.' -f2)

  # Add padding if needed for base64 decoding
  padding=$((4 - ${#payload} % 4))
  if [ $padding -ne 4 ]; then
      payload="${payload}$(printf '%*s' $padding '' | tr ' ' '=')"
  fi

  # Decode base64 payload
  if command -v base64 >/dev/null 2>&1; then
      decoded=$(echo "$payload" | base64 -d 2>/dev/null || echo "")
  else
      print_error "base64 command not found"
      exit 1
  fi

  if [ -n "$decoded" ]; then
      print_success "JWT Token Information:"
      echo

      # Pretty print JSON if jq is available
      if command -v jq >/dev/null 2>&1; then
          echo "$decoded" | jq .
      else
          echo "$decoded"
      fi

      echo
      if command -v jq >/dev/null 2>&1; then
          exp_timestamp=$(echo "$decoded" | jq -r '.exp' 2>/dev/null)
          if [ "$exp_timestamp" != "null" ] && [ -n "$exp_timestamp" ]; then
              exp_date=$(date -r "$exp_timestamp" 2>/dev/null || echo 'unknown')
              print_info "Token expires: $exp_date"
          fi
      fi
  else
      print_error "Failed to decode JWT token"
      exit 1
  fi
}

# :command.function
monk_data_list_command() {

  # src/data_list_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"

  validate_schema "$schema"

  response=$(make_request "GET" "/api/data/$schema" "")
  handle_response "$response" "list"
}

# :command.function
monk_data_get_command() {

  # src/data_get_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  id="${args[id]}"

  validate_schema "$schema"

  response=$(make_request "GET" "/api/data/$schema/$id" "")
  handle_response "$response" "get"
}

# :command.function
monk_data_create_command() {

  # src/data_create_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"

  validate_schema "$schema"

  # Read JSON data from stdin
  json_data=$(cat)

  if [ -z "$json_data" ]; then
      print_error "No JSON data provided on stdin"
      exit 1
  fi

  if [ "$CLI_VERBOSE" = "true" ]; then
      print_info "Creating $schema record with data:"
      echo "$json_data" | sed 's/^/  /'
  fi

  # POST /api/data/:schema expects an array, so wrap single object in array
  array_data="[$json_data]"

  response=$(make_request "POST" "/api/data/$schema" "$array_data")

  # Extract single object from array response to match input format
  if [ "$JSON_PARSER" = "jq" ]; then
      # Extract first item from array response for single-object input
      single_response=$(echo "$response" | jq '{"success": .success, "data": .data[0], "error": .error, "error_code": .error_code}' 2>/dev/null || echo "$response")
      handle_response "$single_response" "create"
  else
      handle_response "$response" "create"
  fi
}

# :command.function
monk_data_update_command() {

  # src/data_update_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  id="${args[id]}"

  validate_schema "$schema"

  # Read JSON data from stdin
  json_data=$(cat)

  if [ -z "$json_data" ]; then
      print_error "No JSON data provided on stdin"
      exit 1
  fi

  if [ "$CLI_VERBOSE" = "true" ]; then
      print_info "Updating $schema record $id with data:"
      echo "$json_data" | sed 's/^/  /'
  fi

  response=$(make_request "PUT" "/api/data/$schema/$id" "$json_data")
  handle_response "$response" "update"
}

# :command.function
monk_data_delete_command() {

  # src/data_delete_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  id="${args[id]}"

  validate_schema "$schema"

  # Confirmation prompt in verbose mode
  if [ "$CLI_VERBOSE" = "true" ]; then
      print_warning "Are you sure you want to delete $schema record: $id? (y/N)" >&2
      read -r confirmation

      if ! echo "$confirmation" | grep -E "^[Yy]$" >/dev/null 2>&1; then
          print_info "Operation cancelled" >&2
          exit 0
      fi
  fi

  response=$(make_request "DELETE" "/api/data/$schema/$id" "")
  handle_response "$response" "delete"
}

# :command.function
monk_data_export_command() {

  # src/data_export_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  directory="${args[dir]}"

  validate_schema "$schema"

  # Create directory if it doesn't exist
  if [ ! -d "$directory" ]; then
      if [ "$CLI_VERBOSE" = "true" ]; then
          print_info "Creating directory: $directory"
      fi
      mkdir -p "$directory"
  fi

  if [ "$CLI_VERBOSE" = "true" ]; then
      print_info "Exporting $schema records to: $directory"
  fi

  # Get all records using the API
  response=$(make_request "GET" "/api/data/$schema" "")

  # Use python3 to parse JSON and export individual files
  if command -v python3 >/dev/null 2>&1; then
      echo "$response" | python3 -c "
  import sys, json, os
  try:
      data = json.load(sys.stdin)
      if data.get('success') and 'data' in data:
          records = data['data']
          count = 0
          for record in records:
              if 'id' in record:
                  filename = os.path.join('$directory', record['id'] + '.json')
                  with open(filename, 'w') as f:
                      json.dump(record, f, indent=4)
                  count += 1
                  if '$CLI_VERBOSE' == 'true':
                      print(f'Exported: {filename}')
              else:
                  print('Warning: Record missing id field', file=sys.stderr)
          print(f'Successfully exported {count} records to $directory')
      else:
          print('Error: Invalid API response format', file=sys.stderr)
          print(f'Response: {data}', file=sys.stderr)
          sys.exit(1)
  except json.JSONDecodeError as e:
      print(f'Error: Invalid JSON in API response: {e}', file=sys.stderr)
      sys.exit(1)
  except Exception as e:
      print(f'Error: {e}', file=sys.stderr)
      sys.exit(1)
  "
  else
      print_error "Python3 required for export functionality"
      print_info "Please install Python 3 to use export operations"
      exit 1
  fi
}

# :command.function
monk_data_import_command() {

  # src/data_import_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  schema="${args[schema]}"
  directory="${args[dir]}"

  validate_schema "$schema"

  if [ ! -d "$directory" ]; then
      print_error "Directory does not exist: $directory"
      exit 1
  fi

  if [ "$CLI_VERBOSE" = "true" ]; then
      print_info "Importing $schema records from: $directory"
  fi

  # Collect all JSON files into an array for bulk import
  if command -v python3 >/dev/null 2>&1; then
      records_json=$(python3 -c "
  import sys, json, os, glob
  records = []
  json_files = glob.glob(os.path.join('$directory', '*.json'))

  if not json_files:
      print('No .json files found in $directory', file=sys.stderr)
      sys.exit(1)

  for filepath in sorted(json_files):
      filename = os.path.basename(filepath)
      try:
          with open(filepath, 'r') as f:
              record = json.load(f)
          records.append(record)
          if '$CLI_VERBOSE' == 'true':
              print(f'Loaded: {filename}', file=sys.stderr)
      except Exception as e:
          print(f'Error loading {filename}: {e}', file=sys.stderr)
          sys.exit(1)

  if '$CLI_VERBOSE' == 'true':
      print(f'Prepared {len(records)} records for import', file=sys.stderr)
  json.dump(records, sys.stdout)
  ")

      if [ -n "$records_json" ]; then
          if [ "$CLI_VERBOSE" = "true" ]; then
              print_info "Making bulk import request..."
          fi

          response=$(make_request "PUT" "/api/data/$schema" "$records_json")

          print_success "Import completed successfully"
          handle_response "$response" "import"
      else
          print_error "Failed to prepare records for import"
          exit 1
      fi
  else
      print_error "Python3 required for import functionality"
      print_info "Please install Python 3 to use import operations"
      exit 1
  fi
}

# :command.function
monk_meta_list_command() {

  # src/meta_list_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  type="${args[type]}"

  # Validate metadata type (currently only schema supported)
  case "$type" in
      schema)
          # Valid type
          ;;
      *)
          print_error "Unsupported metadata type: $type"
          print_info "Currently supported types: schema"
          exit 1
          ;;
  esac

  if [ "$CLI_VERBOSE" = "true" ]; then
      print_info "Listing all $type objects"
  fi

  response=$(make_request "GET" "/api/meta/$type" "")
  handle_response "$response" "list"
}

# :command.function
monk_meta_get_command() {

  # src/meta_get_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  type="${args[type]}"
  name="${args[name]}"

  # Validate metadata type (currently only schema supported)
  case "$type" in
      schema)
          # Valid type
          ;;
      *)
          print_error "Unsupported metadata type: $type"
          print_info "Currently supported types: schema"
          exit 1
          ;;
  esac

  if [ "$CLI_VERBOSE" = "true" ]; then
      print_info "Getting $type object: $name"
  fi

  response=$(make_request "GET" "/api/meta/$type/$name" "")
  handle_response "$response" "get"
}

# :command.function
monk_meta_create_command() {

  # src/meta_create_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  type="${args[type]}"

  # Validate metadata type (currently only schema supported)
  case "$type" in
      schema)
          # Valid type
          ;;
      *)
          print_error "Unsupported metadata type: $type"
          print_info "Currently supported types: schema"
          exit 1
          ;;
  esac

  # Read YAML/JSON data from stdin
  data=$(cat)

  if [ -z "$data" ]; then
      print_error "No YAML/JSON data provided on stdin"
      print_info "Usage: cat schema.yaml | monk meta create schema"
      exit 1
  fi

  if [ "$CLI_VERBOSE" = "true" ]; then
      print_info "Creating $type with data:"
      echo "$data" | sed 's/^/  /'
  fi

  response=$(make_request "POST" "/api/meta/$type" "$data")
  handle_response "$response" "create"
}

# :command.function
monk_meta_update_command() {

  # src/meta_update_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  type="${args[type]}"
  name="${args[name]}"

  # Validate metadata type (currently only schema supported)
  case "$type" in
      schema)
          # Valid type
          ;;
      *)
          print_error "Unsupported metadata type: $type"
          print_info "Currently supported types: schema"
          exit 1
          ;;
  esac

  # Read YAML/JSON data from stdin
  data=$(cat)

  if [ -z "$data" ]; then
      print_error "No YAML/JSON data provided on stdin"
      print_info "Usage: cat schema.yaml | monk meta update schema <name>"
      exit 1
  fi

  if [ "$CLI_VERBOSE" = "true" ]; then
      print_info "Updating $type '$name' with data:"
      echo "$data" | sed 's/^/  /'
  fi

  response=$(make_request "PUT" "/api/meta/$type/$name" "$data")
  handle_response "$response" "update"
}

# :command.function
monk_meta_delete_command() {

  # src/meta_delete_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  type="${args[type]}"
  name="${args[name]}"

  # Validate metadata type (currently only schema supported)
  case "$type" in
      schema)
          # Valid type
          ;;
      *)
          print_error "Unsupported metadata type: $type"
          print_info "Currently supported types: schema"
          exit 1
          ;;
  esac

  if [ "$CLI_VERBOSE" = "true" ]; then
      print_warning "Are you sure you want to delete $type '$name'? (y/N)" >&2
      read -r confirmation

      if ! echo "$confirmation" | grep -E "^[Yy]$" >/dev/null 2>&1; then
          print_info "Operation cancelled" >&2
          exit 0
      fi
  fi

  response=$(make_request "DELETE" "/api/meta/$type/$name" "")
  handle_response "$response" "delete"
}

# :command.function
monk_find_command() {

  # src/find_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments and flags from bashly
  schema="${args[schema]}"
  field_flag="${args[--field]}"
  count_flag="${args[--count]}"
  exit_code_flag="${args[--exit-code]}"
  verbose_flag="${args[--verbose]}"
  head_flag="${args[--head]}"
  tail_flag="${args[--tail]}"

  # Set environment variables based on flags
  if [ "$field_flag" ]; then
      export CLI_EXTRACT_FIELD="$field_flag"
  fi

  if [ "$count_flag" = "1" ]; then
      export CLI_COUNT_MODE=true
  fi

  if [ "$exit_code_flag" = "1" ]; then
      export CLI_EXIT_CODE_ONLY=true
  fi

  if [ "$verbose_flag" = "1" ]; then
      export CLI_VERBOSE=true
  fi

  if [ "$head_flag" = "1" ]; then
      export CLI_HEAD_MODE=true
  fi

  if [ "$tail_flag" = "1" ]; then
      export CLI_TAIL_MODE=true
  fi

  # Check if we have input data
  if [ -t 0 ]; then
      echo '{"error":"find expects JSON search criteria via STDIN","success":false}' >&2
      exit 1
  fi

  # Read JSON data from STDIN
  input_data=$(cat)

  # Validate JSON format (basic check)
  if [ "$JSON_PARSER" = "jq" ]; then
      if ! echo "$input_data" | jq . >/dev/null 2>&1; then
          echo '{"error":"Invalid JSON format in search criteria","success":false}' >&2
          exit 1
      fi
  elif command -v jshon >/dev/null 2>&1; then
      if ! echo "$input_data" | jshon >/dev/null 2>&1; then
          echo '{"error":"Invalid JSON format in search criteria","success":false}' >&2
          exit 1
      fi
  fi

  # Make the find request
  response=$(make_request "POST" "/api/find/$schema" "$input_data")

  # Process response with head/tail support
  if [ "$CLI_HEAD_MODE" = "true" ]; then
      # Extract first record from array
      if [ "$JSON_PARSER" = "jq" ]; then
          if echo "$response" | jq -e '.success == true' >/dev/null 2>&1; then
              first_record=$(echo "$response" | jq '.data[0] // null')
              echo "$response" | jq --argjson first "$first_record" '{"success": .success, "data": $first}'
          else
              echo "$response"
          fi
      else
          # Fallback for jshon or no parser
          if echo "$response" | grep -q '"success":true'; then
              first_record=$(echo "$response" | jshon -e data -e 0 2>/dev/null || echo "null")
              if [ "$first_record" != "null" ]; then
                  echo "{\"success\":true,\"data\":$first_record}"
              else
                  echo '{"success":true,"data":null}'
              fi
          else
              echo "$response"
          fi
      fi
  elif [ "$CLI_TAIL_MODE" = "true" ]; then
      # Extract last record from array
      if [ "$JSON_PARSER" = "jq" ]; then
          if echo "$response" | jq -e '.success == true' >/dev/null 2>&1; then
              last_record=$(echo "$response" | jq '.data[-1] // null')
              echo "$response" | jq --argjson last "$last_record" '{"success": .success, "data": $last}'
          else
              echo "$response"
          fi
      else
          # Fallback for jshon or no parser
          if echo "$response" | grep -q '"success":true'; then
              array_length=$(echo "$response" | jshon -e data -l 2>/dev/null || echo "0")
              if [ "$array_length" -gt 0 ]; then
                  last_index=$((array_length - 1))
                  last_record=$(echo "$response" | jshon -e data -e "$last_index" 2>/dev/null || echo "null")
                  echo "{\"success\":true,\"data\":$last_record}"
              else
                  echo '{"success":true,"data":null}'
              fi
          else
              echo "$response"
          fi
      fi
  else
      # Use standard response handler
      handle_response "$response" "find"
  fi
}

# :command.function
monk_ping_command() {

  # src/ping_command.sh
  # Check dependencies
  check_dependencies

  # Get flags from bashly args
  verbose_flag="${args[--verbose]}"
  jwt_token_arg="${args[--jwt-token]}"

  # Set CLI_VERBOSE if flag is present

  if [ "$verbose_flag" = "1" ] || [ "$verbose_flag" = "true" ]; then
      CLI_VERBOSE=true
  fi

  # Make ping request
  base_url=$(get_base_url)

  if [ "$CLI_VERBOSE" = "true" ]; then
      print_info "Pinging server at: $base_url"
  fi

  # Prepare curl arguments
  curl_args=(-s -X GET -H "Content-Type: application/json")

  # Add JWT token (provided via -j flag or stored token)
  token_to_use="$jwt_token_arg"
  if [ -z "$token_to_use" ]; then
      token_to_use=$(get_jwt_token)
  fi

  if [ -n "$token_to_use" ]; then
      curl_args+=(-H "Authorization: Bearer $token_to_use")
      if [ "$CLI_VERBOSE" = "true" ]; then
          if [ -n "$jwt_token_arg" ]; then
              print_info "Using provided JWT token"
          else
              print_info "Using stored JWT token"
          fi
      fi
  fi

  # Make request
  full_url="${base_url}/ping"
  response=$(curl "${curl_args[@]}" -w "\n%{http_code}" "$full_url")
  http_code=$(echo "$response" | tail -n1)
  response=$(echo "$response" | sed '$d')

  # Handle response
  case "$http_code" in
      200)
          if [ "$CLI_VERBOSE" = "true" ]; then
              print_success "Server is reachable (HTTP $http_code)"
              echo "Response: $response"
          else
              # Parse response for clean output
              if [ "$JSON_PARSER" = "jq" ]; then
                  pong=$(echo "$response" | jq -r '.pong' 2>/dev/null || echo "unknown")
                  domain=$(echo "$response" | jq -r '.domain' 2>/dev/null || echo "null")
                  database=$(echo "$response" | jq -r '.database' 2>/dev/null || echo "null")

                  echo "pong: $pong"
                  if [ "$domain" != "null" ] && [ "$domain" != "" ]; then
                      echo "domain: $domain"
                  fi
                  if [ "$database" != "null" ] && [ "$database" != "" ]; then
                      if [ "$database" = "ok" ]; then
                          echo "database: $database"
                      else
                          echo "database: ERROR - $database"
                      fi
                  fi
              elif [ "$JSON_PARSER" = "jshon" ]; then
                  pong=$(echo "$response" | jshon -e pong -u 2>/dev/null || echo "unknown")
                  domain=$(echo "$response" | jshon -e domain -u 2>/dev/null || echo "null")
                  database=$(echo "$response" | jshon -e database -u 2>/dev/null || echo "null")

                  echo "pong: $pong"
                  if [ "$domain" != "null" ]; then
                      echo "domain: $domain"
                  fi
                  if [ "$database" != "null" ]; then
                      if [ "$database" = "ok" ]; then
                          echo "database: $database"
                      else
                          echo "database: ERROR - $database"
                      fi
                  fi
              else
                  echo "$response"
              fi
          fi
          ;;
      *)
          print_error "Server unreachable (HTTP $http_code)"
          if [ "$CLI_VERBOSE" = "true" ]; then
              echo "Response: $response" >&2
          fi
          exit 1
          ;;
  esac
}

# :command.function
monk_test_git_command() {

  # src/test_git_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  branch="${args[branch]}"
  commit="${args[commit]}"
  clean_build="${args[--clean]}"

  # Configuration
  TEST_CONFIG_FILE="${HOME}/.config/monk/test.json"

  # Load test configuration
  load_test_config() {
      if [ -f "$TEST_CONFIG_FILE" ] && command -v jq >/dev/null 2>&1; then
          local base_dir=$(jq -r '.base_directory // "/tmp/monk-builds"' "$TEST_CONFIG_FILE")
          local git_remote=$(jq -r '.default_settings.git_remote // "https://github.com/ianzepp/monk-api.git"' "$TEST_CONFIG_FILE")
          local port_start=$(jq -r '.default_settings.default_port_range.git_tests.start // 3000' "$TEST_CONFIG_FILE")
          local port_end=$(jq -r '.default_settings.default_port_range.git_tests.end // 3999' "$TEST_CONFIG_FILE")

          echo "$base_dir|$git_remote|$port_start|$port_end"
      else
          echo "/tmp/monk-builds|https://github.com/ianzepp/monk-api.git|3000|3999"
      fi
  }

  # Parse test configuration
  config_data=$(load_test_config)
  GIT_TARGET_DIR=$(echo "$config_data" | cut -d'|' -f1)
  MONK_GIT_REMOTE=$(echo "$config_data" | cut -d'|' -f2)
  PORT_START=$(echo "$config_data" | cut -d'|' -f3)
  PORT_END=$(echo "$config_data" | cut -d'|' -f4)

  # Helper functions
  print_header() { echo -e "\n${YELLOW}=== $1 ===${NC}"; }
  print_step() { echo -e "${BLUE}→ $1${NC}"; }

  # Generate run name from git reference
  generate_run_name() {
      local git_ref="$1"
      local commit_ref="$2"

      # Create input string for hashing
      local hash_input="$git_ref"
      if [ -n "$commit_ref" ]; then
          hash_input="${git_ref}:${commit_ref}"
      fi

      # Generate hash using cksum (portable)
      local checksum=$(echo -n "$hash_input" | cksum | cut -d' ' -f1)
      local hash_suffix=$((checksum % 99999999))

      # Clean up branch name for display
      local clean_branch=$(echo "$git_ref" | sed 's/[^a-zA-Z0-9._-]/-/g' | cut -c1-20)

      # Generate compact run name
      printf "%s-%08d" "$clean_branch" "$hash_suffix"
  }

  # Get next available port from configured range
  get_next_port() {
      local start_port="$PORT_START"
      local end_port="$PORT_END"

      # Find next available port in range
      local test_port=$start_port
      while [ "$test_port" -le "$end_port" ]; do
          if ! lsof -i ":$test_port" >/dev/null 2>&1; then
              echo "$test_port"
              return 0
          fi
          test_port=$((test_port + 1))
      done

      print_error "Could not find available port in range $start_port-$end_port"
      return 1
  }

  # Main execution
  print_header "Git Test Environment Setup"

  # Generate run name
  run_name=$(generate_run_name "$branch" "$commit")
  run_dir="$GIT_TARGET_DIR/$run_name"
  api_dir="$run_dir/monk-api"

  print_info "Branch: $branch"
  if [ -n "$commit" ]; then
      print_info "Commit: $commit"
  fi
  print_info "Run Name: $run_name"
  print_info "Target Directory: $run_dir"

  # Create target directory
  mkdir -p "$GIT_TARGET_DIR"

  # Handle clean build option
  if [ "$clean_build" = "true" ] && [ -d "$run_dir" ]; then
      print_step "Clean build: removing existing environment"
      rm -rf "$run_dir"
  fi

  # Setup git environment
  if [ -d "$api_dir" ]; then
      print_step "Updating existing git environment"
      cd "$api_dir"

      # Fetch latest changes
      if ! git fetch origin >/dev/null 2>&1; then
          print_error "Failed to fetch from remote"
          exit 1
      fi

      # Checkout target reference
      local target_ref="$branch"
      if [ -n "$commit" ]; then
          target_ref="$commit"
      fi

      if ! git checkout "$target_ref" >/dev/null 2>&1; then
          print_error "Failed to checkout $target_ref"
          exit 1
      fi

      if ! git pull origin "$branch" >/dev/null 2>&1; then
          print_info "Could not pull (detached HEAD or local changes)"
      fi
  else
      print_step "Creating fresh git environment"

      # Clone repository
      if ! git clone "$MONK_GIT_REMOTE" "$api_dir" >/dev/null 2>&1; then
          print_error "Failed to clone repository"
          exit 1
      fi

      cd "$api_dir"

      # Checkout target reference
      local target_ref="$branch"
      if [ -n "$commit" ]; then
          target_ref="$commit"
      fi

      if ! git checkout "$target_ref" >/dev/null 2>&1; then
          print_error "Failed to checkout $target_ref"
          exit 1
      fi
  fi

  print_success "Git environment ready"

  # Get allocated port
  allocated_port=$(get_next_port)
  if [ -z "$allocated_port" ]; then
      exit 1
  fi

  print_step "Allocated port: $allocated_port"

  # Create isolated server configuration
  print_step "Creating isolated server configuration"
  config_dir="$api_dir/.config/monk"
  mkdir -p "$config_dir"

  cat > "$config_dir/servers.json" << EOF
{
  "servers": {
    "test-env": {
      "hostname": "localhost",
      "port": $allocated_port,
      "protocol": "http",
      "description": "Git test environment for $branch",
      "created_at": "$(date -u +%Y-%m-%dT%H:%M:%SZ)"
    }
  },
  "current": "test-env"
}
EOF

  print_success "Isolated configuration created"

  # Install dependencies
  print_step "Installing dependencies"
  if ! npm install >/dev/null 2>&1; then
      print_error "npm install failed"
      exit 1
  fi

  print_success "Dependencies installed"

  # Build project
  print_step "Building project"
  if ! npm run build >/dev/null 2>&1; then
      print_error "npm run build failed"
      exit 1
  fi

  print_success "Project built successfully"

  # Update test.json with run information
  update_test_config() {
      local run_name="$1"
      local api_dir="$2"
      local port="$3"

      if [ -f "$TEST_CONFIG_FILE" ] && command -v jq >/dev/null 2>&1; then
          local temp_file=$(mktemp)
          jq --arg run_name "$run_name" \
             --arg api_dir "$api_dir" \
             --arg port "$port" \
             --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
             '.active_run = $run_name |

              .run_history += [{
                  name: $run_name,
                  directory: $api_dir,
                  port: ($port | tonumber),
                  created_at: $timestamp,
                  status: "ready"
              }]' \
             "$TEST_CONFIG_FILE" > "$temp_file" && mv "$temp_file" "$TEST_CONFIG_FILE"
      fi
  }

  update_test_config "$run_name" "$api_dir" "$allocated_port"

  print_header "Git Test Environment Ready"
  print_success "Environment: $run_name"
  print_success "Directory: $api_dir"
  print_success "Server Port: $allocated_port"
  print_success "Configuration: $api_dir/.config/monk/servers.json"
  print_info "Run tests with: cd $api_dir && npm test"
  print_info "View environment: cd $api_dir && npm run test:info"
}

# :command.function
monk_test_diff_command() {

  # src/test_diff_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  run1="${args[run1]}"
  run2="${args[run2]}"

  print_info "Test Diff Comparison (Simplified)"
  echo

  print_info "Run 1: $run1"
  print_info "Run 2: $run2"

  echo
  print_info "Simplified Implementation:"
  print_info "1. Test diff was never properly implemented in original CLI"
  print_info "2. Use 'monk test all' to run current tests"
  print_info "3. Compare results manually or use external diff tools"

  echo
  print_info "For future implementation:"
  print_info "- Compare test results between git branches"
  print_info "- Show differences in test outcomes"
  print_info "- Performance comparison between runs"
}

# :command.function
monk_servers_add_command() {

  # src/servers_add_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"
  endpoint="${args[endpoint]}"
  description="${args[--description]}"

  init_servers_config

  # Parse endpoint
  parsed=$(parse_endpoint "$endpoint")
  protocol=$(echo "$parsed" | cut -d'|' -f1)
  hostname=$(echo "$parsed" | cut -d'|' -f2)
  port=$(echo "$parsed" | cut -d'|' -f3)

  print_info "Adding server: $name"
  print_info "Endpoint: $protocol://$hostname:$port"
  if [ -n "$description" ]; then
      print_info "Description: $description"
  fi

  # Check if server already exists
  if command -v jq >/dev/null 2>&1; then
      if jq -e ".servers.\"$name\"" "$SERVERS_CONFIG" >/dev/null 2>&1; then
          print_error "Server '$name' already exists"
          print_info "Use 'monk servers delete $name' first, or choose a different name"
          exit 1
      fi
  fi

  # Test connectivity
  print_info "Testing connectivity to $protocol://$hostname:$port"
  base_url="$protocol://$hostname:$port"

  if ping_server_url "$base_url"; then
      print_success "Server is reachable"
      status="up"
  else
      print_info "Server appears to be down (this is OK, adding anyway)"
      status="down"
  fi

  # Add server to config
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  if command -v jq >/dev/null 2>&1; then
      # Use jq for JSON manipulation
      temp_file=$(mktemp)
      jq --arg name "$name" \
         --arg hostname "$hostname" \
         --arg port "$port" \
         --arg protocol "$protocol" \
         --arg description "$description" \
         --arg timestamp "$timestamp" \
         --arg status "$status" \
         '.servers[$name] = {
             "hostname": $hostname,
             "port": ($port | tonumber),
             "protocol": $protocol,
             "description": $description,
             "added_at": $timestamp,
             "last_ping": $timestamp,
             "status": $status
         }' "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"

      print_success "Server '$name' added successfully"

      # If this is the first server, make it current
      server_count=$(jq '.servers | length' "$SERVERS_CONFIG")
      if [ "$server_count" -eq 1 ]; then
          jq --arg name "$name" '.current = $name' "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"
          print_info "Set as current server (first server added)"
      fi
  else
      print_error "jq is required for server management"
      print_info "Please install jq: brew install jq (macOS) or apt-get install jq (Linux)"
      exit 1
  fi
}

# :command.function
monk_servers_list_command() {

  # src/servers_list_command.sh
  # Check dependencies
  check_dependencies

  init_servers_config

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  echo
  print_info "Registered Servers"
  echo

  current_server=$(jq -r '.current // empty' "$SERVERS_CONFIG" 2>/dev/null)

  server_names=$(jq -r '.servers | keys[]' "$SERVERS_CONFIG" 2>/dev/null)

  if [ -z "$server_names" ]; then
      print_info "No servers configured"
      print_info "Use 'monk servers add <name> <hostname:port>' to add servers"
      exit 0
  fi

  printf "%-15s %-30s %-8s %-8s %-12s %-20s %s\n" "Name" "Endpoint" "Status" "Auth" "Last Ping" "Added" "Description"
  echo "--------------------------------------------------------------------------------------------------------"

  echo "$server_names" | while read -r name; do
      if [ -n "$name" ]; then
          server_info=$(jq -r ".servers.\"$name\"" "$SERVERS_CONFIG")

          hostname=$(echo "$server_info" | jq -r '.hostname')
          port=$(echo "$server_info" | jq -r '.port')
          protocol=$(echo "$server_info" | jq -r '.protocol')
          status=$(echo "$server_info" | jq -r '.status // "unknown"')
          jwt_token=$(echo "$server_info" | jq -r '.jwt_token // ""')
          last_ping=$(echo "$server_info" | jq -r '.last_ping // "never"')
          added_at=$(echo "$server_info" | jq -r '.added_at // "unknown"')
          description=$(echo "$server_info" | jq -r '.description // ""')

          endpoint="$protocol://$hostname:$port"

          # Format timestamps
          if [ "$last_ping" != "never" ] && [ "$last_ping" != "unknown" ]; then
              last_ping=$(echo "$last_ping" | cut -d'T' -f1)
          fi
          if [ "$added_at" != "unknown" ]; then
              added_at=$(echo "$added_at" | cut -d'T' -f1)
          fi

          # Check if authenticated
          auth_status="no"
          if [ -n "$jwt_token" ]; then
              auth_status="yes"
          fi

          # Mark current server
          marker=""
          if [ "$name" = "$current_server" ]; then
              marker="*"
          fi

          printf "%-15s %-30s %-8s %-8s %-12s %-20s %s %s\n" \
              "$name" "$endpoint" "$status" "$auth_status" "$last_ping" "$added_at" "$description" "$marker"
      fi
  done

  echo
  if [ -n "$current_server" ]; then
      print_info "Current server: $current_server (marked with *)"
  else
      print_info "No current server selected"
      print_info "Use 'monk servers use <name>' to select a server"
  fi
}

# :command.function
monk_servers_current_command() {

  # src/servers_current_command.sh
  # Check dependencies
  check_dependencies

  init_servers_config

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  current_server=$(jq -r '.current // empty' "$SERVERS_CONFIG" 2>/dev/null)

  if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
      print_info "No current server selected"
      print_info "Use 'monk servers use <name>' to select a server"
      exit 0
  fi

  server_info=$(jq -r ".servers.\"$current_server\"" "$SERVERS_CONFIG" 2>/dev/null)
  if [ "$server_info" = "null" ]; then
      print_error "Current server '$current_server' not found in registry"
      print_info "The server may have been deleted. Use 'monk servers list' to see available servers"
      exit 1
  fi

  echo
  print_info "Current Server"
  echo

  hostname=$(echo "$server_info" | jq -r '.hostname')
  port=$(echo "$server_info" | jq -r '.port')
  protocol=$(echo "$server_info" | jq -r '.protocol')
  status=$(echo "$server_info" | jq -r '.status // "unknown"')
  description=$(echo "$server_info" | jq -r '.description // ""')

  echo "Name: $current_server"
  echo "Endpoint: $protocol://$hostname:$port"
  echo "Status: $status"
  if [ -n "$description" ]; then
      echo "Description: $description"
  fi

  # Show calculated base URL
  base_url="$protocol://$hostname:$port"
  echo "Base URL: $base_url"
}

# :command.function
monk_servers_use_command() {

  # src/servers_use_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  init_servers_config

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # If no name provided, show current server (alias for 'current' command)
  if [ -z "$name" ]; then
      current_server=$(jq -r '.current // empty' "$SERVERS_CONFIG" 2>/dev/null)

      if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
          print_info "No current server selected"
          print_info "Use 'monk servers use <name>' to select a server"
          exit 0
      fi

      server_info=$(jq -r ".servers.\"$current_server\"" "$SERVERS_CONFIG" 2>/dev/null)
      if [ "$server_info" = "null" ]; then
          print_error "Current server '$current_server' not found in registry"
          print_info "The server may have been deleted. Use 'monk servers list' to see available servers"
          exit 1
      fi

      echo
      print_info "Current Server"
      echo

      hostname=$(echo "$server_info" | jq -r '.hostname')
      port=$(echo "$server_info" | jq -r '.port')
      protocol=$(echo "$server_info" | jq -r '.protocol')
      status=$(echo "$server_info" | jq -r '.status // "unknown"')
      description=$(echo "$server_info" | jq -r '.description // ""')

      echo "Name: $current_server"
      echo "Endpoint: $protocol://$hostname:$port"
      echo "Status: $status"
      if [ -n "$description" ]; then
          echo "Description: $description"
      fi

      # Show calculated base URL
      base_url="$protocol://$hostname:$port"
      echo "Base URL: $base_url"
      exit 0
  fi

  # Check if server exists
  server_info=$(jq -r ".servers.\"$name\"" "$SERVERS_CONFIG" 2>/dev/null)
  if [ "$server_info" = "null" ]; then
      print_error "Server '$name' not found"
      print_info "Use 'monk servers list' to see available servers"
      exit 1
  fi

  # Set as current server
  temp_file=$(mktemp)
  jq --arg name "$name" '.current = $name' "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"

  # Get server details for confirmation
  hostname=$(echo "$server_info" | jq -r '.hostname')
  port=$(echo "$server_info" | jq -r '.port')
  protocol=$(echo "$server_info" | jq -r '.protocol')
  base_url="$protocol://$hostname:$port"

  print_success "Switched to server: $name"
  print_info "Endpoint: $base_url"
  print_info "All monk commands will now use this server"
  print_info "Base URL: $base_url"
}

# :command.function
monk_servers_delete_command() {

  # src/servers_delete_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  init_servers_config

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # Check if server exists
  if ! jq -e ".servers.\"$name\"" "$SERVERS_CONFIG" >/dev/null 2>&1; then
      print_error "Server '$name' not found"
      print_info "Use 'monk servers list' to see available servers"
      exit 1
  fi

  print_info "Deleting server: $name"

  # Remove server from config
  temp_file=$(mktemp)
  jq --arg name "$name" 'del(.servers[$name])' "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"

  # If this was the current server, clear current
  current_server=$(jq -r '.current // empty' "$SERVERS_CONFIG" 2>/dev/null)
  if [ "$current_server" = "$name" ]; then
      jq '.current = null' "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"
      print_info "Cleared current server (was deleted server)"
  fi

  print_success "Server '$name' deleted successfully"
}

# :command.function
monk_servers_ping_command() {

  # src/servers_ping_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  init_servers_config

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # Get server info
  server_info=$(jq -r ".servers.\"$name\"" "$SERVERS_CONFIG" 2>/dev/null)
  if [ "$server_info" = "null" ]; then
      print_error "Server '$name' not found"
      print_info "Use 'monk servers list' to see available servers"
      exit 1
  fi

  hostname=$(echo "$server_info" | jq -r '.hostname')
  port=$(echo "$server_info" | jq -r '.port')
  protocol=$(echo "$server_info" | jq -r '.protocol')
  base_url="$protocol://$hostname:$port"

  print_info "Pinging server: $name ($base_url)"

  if ping_server_url "$base_url" 10; then
      print_success "Server is up and responding"

      # Update status in config
      timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
      temp_file=$(mktemp)
      jq --arg name "$name" \
         --arg timestamp "$timestamp" \
         '.servers[$name].last_ping = $timestamp | .servers[$name].status = "up"' \
         "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"
  else
      print_error "Server is down or not responding"

      # Update status in config
      timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
      temp_file=$(mktemp)
      jq --arg name "$name" \
         --arg timestamp "$timestamp" \
         '.servers[$name].last_ping = $timestamp | .servers[$name].status = "down"' \
         "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"
      exit 1
  fi
}

# :command.function
monk_servers_ping_all_command() {

  # src/servers_ping_all_command.sh
  # Check dependencies
  check_dependencies

  init_servers_config

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  echo
  print_info "Pinging All Servers"
  echo

  server_names=$(jq -r '.servers | keys[]' "$SERVERS_CONFIG" 2>/dev/null)

  if [ -z "$server_names" ]; then
      print_info "No servers configured"
      print_info "Use 'monk servers add <name> <hostname:port>' to add servers"
      exit 0
  fi

  up_count=0
  total_count=0

  # Use temp file to avoid subshell variable issues
  temp_results=$(mktemp)

  echo "$server_names" | while read -r name; do
      if [ -n "$name" ]; then
          echo "$((total_count + 1))" > "$temp_results.count"

          server_info=$(jq -r ".servers.\"$name\"" "$SERVERS_CONFIG")
          hostname=$(echo "$server_info" | jq -r '.hostname')
          port=$(echo "$server_info" | jq -r '.port')
          protocol=$(echo "$server_info" | jq -r '.protocol')
          base_url="$protocol://$hostname:$port"

          print_info "Pinging server: $name ($base_url)"

          if ping_server_url "$base_url" 5; then
              print_success "Server is up and responding"
              # Update status
              timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
              temp_file=$(mktemp)
              jq --arg name "$name" \
                 --arg timestamp "$timestamp" \
                 '.servers[$name].last_ping = $timestamp | .servers[$name].status = "up"' \
                 "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"

              # Count successful pings
              if [ -f "$temp_results.up" ]; then
                  up_count=$(cat "$temp_results.up")
              else
                  up_count=0
              fi
              echo "$((up_count + 1))" > "$temp_results.up"
          else
              print_error "Server is down or not responding"
              # Update status
              timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
              temp_file=$(mktemp)
              jq --arg name "$name" \
                 --arg timestamp "$timestamp" \
                 '.servers[$name].last_ping = $timestamp | .servers[$name].status = "down"' \
                 "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"
          fi
      fi
  done

  # Read final counts
  if [ -f "$temp_results.count" ]; then
      total_count=$(cat "$temp_results.count")
  else
      total_count=0
  fi

  if [ -f "$temp_results.up" ]; then
      up_count=$(cat "$temp_results.up")
  else
      up_count=0
  fi

  # Clean up temp files
  rm -f "$temp_results" "$temp_results.count" "$temp_results.up"

  echo
  if [ "$up_count" -eq "$total_count" ] && [ "$total_count" -gt 0 ]; then
      print_success "All servers are up ($up_count/$total_count)"
  elif [ "$up_count" -eq 0 ] && [ "$total_count" -gt 0 ]; then
      print_error "All servers are down (0/$total_count)"
  elif [ "$total_count" -gt 0 ]; then
      print_info "$up_count/$total_count servers are up"
  fi
}

# :command.function
monk_tenant_create_command() {

  # src/tenant_create_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  tenant_name="${args[name]}"
  host="${args[--host]}"
  force_flag="${args[--force]}"

  # Generate database name: monk-api$ + snake_case conversion
  database_name="monk-api\$$(echo "$tenant_name" | sed 's/[^a-zA-Z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g' | tr '[:upper:]' '[:lower:]')"

  print_info "Creating tenant: $tenant_name"
  print_info "Database name: $database_name"

  db_user=$(whoami)

  # Check if database already exists
  if psql -U "$db_user" -lqt | cut -d'|' -f1 | grep -qw "$database_name" 2>/dev/null; then
      if [ "$force_flag" = "1" ]; then
          print_info "Database '$database_name' exists, dropping it (--force flag)"

          # Remove tenant record from auth database first
          sql_delete="DELETE FROM tenants WHERE database = '$database_name';"
          if ! psql -U "$db_user" -d monk-api-auth -c "$sql_delete" >/dev/null 2>&1; then
              print_info "No existing tenant record found in auth database (continuing)"
          fi

          # Drop the existing database
          if ! dropdb "$database_name" -U "$db_user" 2>/dev/null; then
              print_error "Failed to drop existing database '$database_name'"
              exit 1
          fi
          print_success "Existing database '$database_name' dropped"
      else
          print_error "Database '$database_name' already exists (use --force to override)"
          exit 1
      fi
  fi

  # First create the actual PostgreSQL database
  if createdb "$database_name" -U "$db_user" 2>/dev/null; then
      print_success "Database '$database_name' created successfully"

      # Initialize tenant database with required schema tables
      if ! init_tenant_schema "$database_name" "$db_user"; then
          # Clean up the database we created
          dropdb "$database_name" -U "$db_user" 2>/dev/null || true
          exit 1
      fi

      # Insert default root user for the tenant
      root_user_sql="INSERT INTO users (tenant_name, name, access) VALUES ('$tenant_name', 'root', 'root');"
      if ! psql -U "$db_user" -d "$database_name" -c "$root_user_sql" >/dev/null 2>&1; then
          print_error "Failed to create root user for tenant"
          # Clean up the database we created
          dropdb "$database_name" -U "$db_user" 2>/dev/null || true
          exit 1
      fi
      print_success "Root user created for tenant"
  else
      print_error "Failed to create database '$database_name'"
      exit 1
  fi

  # Then insert record into auth database tenants table
  sql_insert="INSERT INTO tenants (name, host, database) VALUES ('$tenant_name', '$host', '$database_name');"

  if psql -U "$db_user" -d monk-api-auth -c "$sql_insert" >/dev/null 2>&1; then
      print_success "Tenant record created in auth database"
      print_info "Tenant: $tenant_name on host: $host"
      print_info "Database: $database_name"
  else
      print_error "Failed to create tenant record in auth database"
      # Clean up the database we created
      dropdb "$database_name" -U "$db_user" 2>/dev/null || true
      exit 1
  fi
}

# :command.function
monk_tenant_delete_command() {

  # src/tenant_delete_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  tenant_name="${args[name]}"

  print_info "Deleting tenant: $tenant_name"

  db_user=$(whoami)

  # Get database name from tenant record
  database_name=$(psql -U "$db_user" -d monk-api-auth -t -c "SELECT database FROM tenants WHERE name = '$tenant_name';" 2>/dev/null | tr -d ' ')

  if [ -z "$database_name" ]; then
      print_error "Tenant '$tenant_name' not found in auth database"
      exit 1
  fi

  print_info "Database name: $database_name"

  # Check if database exists
  if ! psql -U "$db_user" -lqt | cut -d'|' -f1 | grep -qw "$database_name" 2>/dev/null; then
      print_error "Database '$database_name' does not exist"
      exit 1
  fi

  # First remove record from auth database tenants table
  sql_delete="DELETE FROM tenants WHERE name = '$tenant_name';"

  if psql -U "$db_user" -d monk-api-auth -c "$sql_delete" >/dev/null 2>&1; then
      print_success "Tenant record removed from auth database"
  else
      print_error "Failed to remove tenant record from auth database"
      exit 1
  fi

  # Then drop the actual PostgreSQL database
  if dropdb "$database_name" -U "$db_user" 2>/dev/null; then
      print_success "Database '$database_name' deleted successfully"
  else
      print_error "Failed to delete database '$database_name'"
      exit 1
  fi
}

# :command.function
monk_tenant_init_command() {

  # src/tenant_init_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  tenant_name="${args[name]}"

  print_info "Re-initializing tenant database: $tenant_name"

  db_user=$(whoami)

  # Check if database exists
  if ! psql -U "$db_user" -lqt | cut -d'|' -f1 | grep -qw "$tenant_name" 2>/dev/null; then
      print_error "Database '$tenant_name' does not exist"
      print_info "Use 'monk tenant create $tenant_name' to create it first"
      exit 1
  fi

  # Drop and recreate database
  print_info "Dropping existing database..."
  if dropdb "$tenant_name" -U "$db_user" 2>/dev/null; then
      print_success "Database dropped"
  else
      print_error "Failed to drop database '$tenant_name'"
      exit 1
  fi

  print_info "Creating fresh database..."
  if createdb "$tenant_name" -U "$db_user" 2>/dev/null; then
      print_success "Database recreated"
  else
      print_error "Failed to recreate database '$tenant_name'"
      exit 1
  fi

  # Initialize with schema
  if ! init_tenant_schema "$tenant_name" "$db_user"; then
      exit 1
  fi

  print_success "Tenant database re-initialized successfully"
}

# :command.function
monk_tenant_list_command() {

  # src/tenant_list_command.sh
  # Check dependencies
  check_dependencies

  print_info "Listing all tenant databases"
  echo

  db_user=$(whoami)

  # Print header
  printf "%-30s %-40s %-20s %-8s %-8s %-8s %-8s %s\n" \
      "TENANT" \
      "DATABASE" \
      "HOST" \
      "STATUS" \
      "DB" \
      "SCHEMAS" \
      "COLUMNS" \
      "CREATED"
  echo "$(printf '%.s-' {1..120})"

  # Get tenant records from auth database
  tenants_query="SELECT name, database, host, is_active, created_at FROM tenants ORDER BY name;"

  # Use temporary file to avoid pipe subshell issues
  temp_file=$(mktemp)
  if psql -U "$db_user" -d monk-api-auth -t -c "$tenants_query" 2>/dev/null > "$temp_file"; then
      while IFS='|' read -r name database host is_active created_at; do
          # Clean up the fields (remove leading/trailing spaces)
          name=$(echo "$name" | xargs)
          database=$(echo "$database" | xargs)
          host=$(echo "$host" | xargs)

          is_active=$(echo "$is_active" | xargs)

          # Skip empty lines
          [ -z "$name" ] && continue

          # Get database stats if host is localhost
          schemas="?"
          columns="?"
          status="remote"

          if [ "$host" = "localhost" ]; then
              # Check if database exists locally
              if psql -U "$db_user" -lqt | cut -d'|' -f1 | grep -qw "$database" 2>/dev/null; then
                  status="local"
                  # Count tables in public schema
                  schema_count=$(psql -U "$db_user" -d "$database" -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';" 2>/dev/null || echo "0")
                  schemas=$(echo "$schema_count" | xargs)

                  # Count columns across all tables in public schema
                  column_count=$(psql -U "$db_user" -d "$database" -t -c "SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = 'public';" 2>/dev/null || echo "0")
                  columns=$(echo "$column_count" | xargs)
              else
                  status="missing"
              fi
          fi

          # Format active status
          active_display="inactive"
          if [ "$is_active" = "t" ]; then
              active_display="active"
          fi

          # Format created date
          created_display=$(echo "$created_at" | cut -d'.' -f1)

          printf "%-30s %-40s %-20s %-8s %-8s %-8s %-8s %s\n" \
              "$name" \
              "$database" \
              "$host" \
              "$active_display" \
              "$status" \
              "$schemas" \
              "$columns" \
              "$created_display"

      done < "$temp_file"
      rm -f "$temp_file"
  else
      rm -f "$temp_file"
      print_error "Failed to query tenants from auth database"
      exit 1
  fi
}

# :command.function
monk_tenant_use_command() {

  # src/tenant_use_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  tenant_name="${args[name]}"

  print_info "Switching to tenant: $tenant_name"

  # Store tenant context in environment
  export CLI_TENANT="$tenant_name"

  # Optionally store in config file for persistence
  config_dir="$HOME/.monk"
  mkdir -p "$config_dir"
  echo "$tenant_name" > "$config_dir/current_tenant"

  print_success "Switched to tenant '$tenant_name'"
  print_info "Use 'monk auth login --domain $tenant_name' to authenticate"
}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        monk_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  env_var_names+=("CLI_VERBOSE")
  env_var_names+=("JWT_TOKEN")

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    auth)
      action="auth"
      shift
      monk_auth_parse_requirements "$@"
      shift $#
      ;;

    data)
      action="data"
      shift
      monk_data_parse_requirements "$@"
      shift $#
      ;;

    meta)
      action="meta"
      shift
      monk_meta_parse_requirements "$@"
      shift $#
      ;;

    find)
      action="find"
      shift
      monk_find_parse_requirements "$@"
      shift $#
      ;;

    ping)
      action="ping"
      shift
      monk_ping_parse_requirements "$@"
      shift $#
      ;;

    test)
      action="test"
      shift
      monk_test_parse_requirements "$@"
      shift $#
      ;;

    servers)
      action="servers"
      shift
      monk_servers_parse_requirements "$@"
      shift $#
      ;;

    tenant)
      action="tenant"
      shift
      monk_tenant_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    login)
      action="login"
      shift
      monk_auth_login_parse_requirements "$@"
      shift $#
      ;;

    logout)
      action="logout"
      shift
      monk_auth_logout_parse_requirements "$@"
      shift $#
      ;;

    status)
      action="status"
      shift
      monk_auth_status_parse_requirements "$@"
      shift $#
      ;;

    token)
      action="token"
      shift
      monk_auth_token_parse_requirements "$@"
      shift $#
      ;;

    info)
      action="info"
      shift
      monk_auth_info_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_auth_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_login_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_login_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth login"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['tenant']+x} ]]; then
          args['tenant']=$1
          shift
        # :argument.case
        elif [[ -z ${args['username']+x} ]]; then
          args['username']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['tenant']+x} ]]; then
    printf "missing required argument: TENANT\nusage: monk auth login TENANT USERNAME\n" >&2

    exit 1
  fi

  if [[ -z ${args['username']+x} ]]; then
    printf "missing required argument: USERNAME\nusage: monk auth login TENANT USERNAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_auth_logout_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_logout_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth logout"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_status_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_status_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth status"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_token_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_token_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth token"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_info_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_info_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth info"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_data_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    list)
      action="list"
      shift
      monk_data_list_parse_requirements "$@"
      shift $#
      ;;

    get)
      action="get"
      shift
      monk_data_get_parse_requirements "$@"
      shift $#
      ;;

    create)
      action="create"
      shift
      monk_data_create_parse_requirements "$@"
      shift $#
      ;;

    update)
      action="update"
      shift
      monk_data_update_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_data_delete_parse_requirements "$@"
      shift $#
      ;;

    export)
      action="export"
      shift
      monk_data_export_parse_requirements "$@"
      shift $#
      ;;

    import)
      action="import"
      shift
      monk_data_import_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_data_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_data_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data list SCHEMA\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_get_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_get_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data get"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data get SCHEMA ID\n" >&2

    exit 1
  fi

  if [[ -z ${args['id']+x} ]]; then
    printf "missing required argument: ID\nusage: monk data get SCHEMA ID\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data create SCHEMA\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_update_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data update"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data update SCHEMA ID\n" >&2

    exit 1
  fi

  if [[ -z ${args['id']+x} ]]; then
    printf "missing required argument: ID\nusage: monk data update SCHEMA ID\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data delete SCHEMA ID\n" >&2

    exit 1
  fi

  if [[ -z ${args['id']+x} ]]; then
    printf "missing required argument: ID\nusage: monk data delete SCHEMA ID\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_export_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_export_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data export"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['dir']+x} ]]; then
          args['dir']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data export SCHEMA DIR\n" >&2

    exit 1
  fi

  if [[ -z ${args['dir']+x} ]]; then
    printf "missing required argument: DIR\nusage: monk data export SCHEMA DIR\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_import_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_import_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data import"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['dir']+x} ]]; then
          args['dir']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data import SCHEMA DIR\n" >&2

    exit 1
  fi

  if [[ -z ${args['dir']+x} ]]; then
    printf "missing required argument: DIR\nusage: monk data import SCHEMA DIR\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_meta_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_meta_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    list)
      action="list"
      shift
      monk_meta_list_parse_requirements "$@"
      shift $#
      ;;

    get)
      action="get"
      shift
      monk_meta_get_parse_requirements "$@"
      shift $#
      ;;

    create)
      action="create"
      shift
      monk_meta_create_parse_requirements "$@"
      shift $#
      ;;

    update)
      action="update"
      shift
      monk_meta_update_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_meta_delete_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_meta_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_meta_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_meta_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="meta list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['type']+x} ]]; then
          args['type']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['type']:-} ]] || args['type']="schema"

}

# :command.parse_requirements
monk_meta_get_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_meta_get_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="meta get"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['type']+x} ]]; then
          args['type']=$1
          shift
        # :argument.case
        elif [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['type']+x} ]]; then
    printf "missing required argument: TYPE\nusage: monk meta get TYPE NAME\n" >&2

    exit 1
  fi

  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk meta get TYPE NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_meta_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_meta_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="meta create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['type']+x} ]]; then
          args['type']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['type']+x} ]]; then
    printf "missing required argument: TYPE\nusage: monk meta create TYPE\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_meta_update_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_meta_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="meta update"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['type']+x} ]]; then
          args['type']=$1
          shift
        # :argument.case
        elif [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['type']+x} ]]; then
    printf "missing required argument: TYPE\nusage: monk meta update TYPE NAME\n" >&2

    exit 1
  fi

  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk meta update TYPE NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_meta_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_meta_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="meta delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['type']+x} ]]; then
          args['type']=$1
          shift
        # :argument.case
        elif [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['type']+x} ]]; then
    printf "missing required argument: TYPE\nusage: monk meta delete TYPE NAME\n" >&2

    exit 1
  fi

  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk meta delete TYPE NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_find_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_find_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="find"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --field | -f)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--field']="$2"
          shift
          shift
        else
          printf "%s\n" "--field requires an argument: --field, -f FIELD" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --count | -c)

        # :flag.case_no_arg
        args['--count']=1
        shift
        ;;

      # :flag.case
      --exit-code | -x)

        # :flag.case_no_arg
        args['--exit-code']=1
        shift
        ;;

      # :flag.case
      --verbose | -v)

        # :flag.case_no_arg
        args['--verbose']=1
        shift
        ;;

      # :flag.case
      --head | -H)

        # :flag.case_no_arg
        args['--head']=1
        shift
        ;;

      # :flag.case
      --tail | -T)

        # :flag.case_no_arg
        args['--tail']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk find SCHEMA [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_ping_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_ping_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="ping"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --verbose | -v)

        # :flag.case_no_arg
        args['--verbose']=1
        shift
        ;;

      # :flag.case
      --jwt-token | -j)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--jwt-token']="$2"
          shift
          shift
        else
          printf "%s\n" "--jwt-token requires an argument: --jwt-token, -j TOKEN" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_test_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_test_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    git)
      action="git"
      shift
      monk_test_git_parse_requirements "$@"
      shift $#
      ;;

    diff)
      action="diff"
      shift
      monk_test_diff_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_test_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_test_git_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_test_git_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="test git"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --clean)

        # :flag.case_no_arg
        args['--clean']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['branch']+x} ]]; then
          args['branch']=$1
          shift
        # :argument.case
        elif [[ -z ${args['commit']+x} ]]; then
          args['commit']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['branch']+x} ]]; then
    printf "missing required argument: BRANCH\nusage: monk test git BRANCH [COMMIT] [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_test_diff_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_test_diff_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="test diff"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['run1']+x} ]]; then
          args['run1']=$1
          shift
        # :argument.case
        elif [[ -z ${args['run2']+x} ]]; then
          args['run2']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['run1']+x} ]]; then
    printf "missing required argument: RUN1\nusage: monk test diff RUN1 RUN2\n" >&2

    exit 1
  fi

  if [[ -z ${args['run2']+x} ]]; then
    printf "missing required argument: RUN2\nusage: monk test diff RUN1 RUN2\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_servers_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_servers_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    add)
      action="add"
      shift
      monk_servers_add_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      monk_servers_list_parse_requirements "$@"
      shift $#
      ;;

    current)
      action="current"
      shift
      monk_servers_current_parse_requirements "$@"
      shift $#
      ;;

    use)
      action="use"
      shift
      monk_servers_use_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_servers_delete_parse_requirements "$@"
      shift $#
      ;;

    ping)
      action="ping"
      shift
      monk_servers_ping_parse_requirements "$@"
      shift $#
      ;;

    ping-all)
      action="ping-all"
      shift
      monk_servers_ping_all_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_servers_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_servers_add_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_servers_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="servers add"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --description)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--description']="$2"
          shift
          shift
        else
          printf "%s\n" "--description requires an argument: --description DESCRIPTION" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        # :argument.case
        elif [[ -z ${args['endpoint']+x} ]]; then
          args['endpoint']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk servers add NAME ENDPOINT [OPTIONS]\n" >&2

    exit 1
  fi

  if [[ -z ${args['endpoint']+x} ]]; then
    printf "missing required argument: ENDPOINT\nusage: monk servers add NAME ENDPOINT [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_servers_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_servers_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="servers list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_servers_current_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_servers_current_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="servers current"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_servers_use_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_servers_use_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="servers use"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
monk_servers_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_servers_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="servers delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk servers delete NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_servers_ping_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_servers_ping_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="servers ping"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk servers ping NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_servers_ping_all_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_servers_ping_all_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="servers ping-all"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_tenant_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    create)
      action="create"
      shift
      monk_tenant_create_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_tenant_delete_parse_requirements "$@"
      shift $#
      ;;

    init)
      action="init"
      shift
      monk_tenant_init_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      monk_tenant_list_parse_requirements "$@"
      shift $#
      ;;

    use)
      action="use"
      shift
      monk_tenant_use_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_tenant_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_tenant_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --host)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--host']="$2"
          shift
          shift
        else
          printf "%s\n" "--host requires an argument: --host HOST" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --force | -f)

        # :flag.case_no_arg
        args['--force']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk tenant create NAME [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--host']:-} ]] || args['--host']="localhost"

}

# :command.parse_requirements
monk_tenant_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk tenant delete NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_tenant_init_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_init_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant init"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk tenant init NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_tenant_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_tenant_use_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_use_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant use"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk tenant use NAME\n" >&2

    exit 1
  fi

}

# :command.initialize
initialize() {
  declare -g version="1.0.0"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "auth") monk_auth_command ;;
    "auth login") monk_auth_login_command ;;
    "auth logout") monk_auth_logout_command ;;
    "auth status") monk_auth_status_command ;;
    "auth token") monk_auth_token_command ;;
    "auth info") monk_auth_info_command ;;
    "data") monk_data_command ;;
    "data list") monk_data_list_command ;;
    "data get") monk_data_get_command ;;
    "data create") monk_data_create_command ;;
    "data update") monk_data_update_command ;;
    "data delete") monk_data_delete_command ;;
    "data export") monk_data_export_command ;;
    "data import") monk_data_import_command ;;
    "meta") monk_meta_command ;;
    "meta list") monk_meta_list_command ;;
    "meta get") monk_meta_get_command ;;
    "meta create") monk_meta_create_command ;;
    "meta update") monk_meta_update_command ;;
    "meta delete") monk_meta_delete_command ;;
    "find") monk_find_command ;;
    "ping") monk_ping_command ;;
    "test") monk_test_command ;;
    "test git") monk_test_git_command ;;
    "test diff") monk_test_diff_command ;;
    "servers") monk_servers_command ;;
    "servers add") monk_servers_add_command ;;
    "servers list") monk_servers_list_command ;;
    "servers current") monk_servers_current_command ;;
    "servers use") monk_servers_use_command ;;
    "servers delete") monk_servers_delete_command ;;
    "servers ping") monk_servers_ping_command ;;
    "servers ping-all") monk_servers_ping_all_command ;;
    "tenant") monk_tenant_command ;;
    "tenant create") monk_tenant_create_command ;;
    "tenant delete") monk_tenant_delete_command ;;
    "tenant init") monk_tenant_init_command ;;
    "tenant list") monk_tenant_list_command ;;
    "tenant use") monk_tenant_use_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
