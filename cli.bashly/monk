#!/usr/bin/env bash
# This script was generated by bashly 1.3.1 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
monk_usage() {
  printf "monk - Monk CLI - Command-line interface for PaaS Backend API\n\n"

  printf "%s\n" "Usage:"
  printf "  monk COMMAND\n"
  printf "  monk [COMMAND] --help | -h\n"
  printf "  monk --version | -v\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Authentication and token management\n" "auth   "
  printf "  %s   Data operations on dynamic schemas\n" "data   "
  printf "  %s   Schema and metadata management\n" "meta   "
  printf "  %s   Advanced search with filter DSL\n" "find   "
  printf "  %s   Server connectivity testing\n" "ping   "
  printf "  %s   Comprehensive test management\n" "test   "
  printf "  %s   Database pool management\n" "pool   "
  printf "  %s   Remote server management\n" "servers"
  printf "  %s   Multi-tenant database management\n" "tenant "
  printf "  %s   User management and access control\n" "user   "
  printf "  %s   System administration\n" "root   "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

    # :command.usage_environment_variables
    printf "%s\n" "Environment Variables:"

    # :environment_variable.usage
    printf "  %s\n" "CLI_BASE_URL"
    printf "    Target API server (auto-detected from monk test env)\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "CLI_VERBOSE"
    printf "    Enable verbose output for all commands\n"
    echo

    # :environment_variable.usage
    printf "  %s\n" "JWT_TOKEN"
    printf "    Authentication token (managed by monk auth)\n"
    echo

  fi
}

# :command.usage
monk_auth_usage() {
  printf "monk auth - Authentication and token management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth COMMAND\n"
  printf "  monk auth [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Authenticate with database domain\n" "login "
  printf "  %s   Clear stored JWT token\n" "logout"
  printf "  %s   Show authentication status\n" "status"
  printf "  %s   Display current JWT token\n" "token "
  printf "  %s   Decode and display JWT token contents\n" "info  "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_login_usage() {
  printf "monk auth login - Authenticate with database domain\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth login [OPTIONS]\n"
  printf "  monk auth login --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--domain DOMAIN (required)"
    printf "    Database domain name\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_logout_usage() {
  printf "monk auth logout - Clear stored JWT token\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth logout\n"
  printf "  monk auth logout --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_status_usage() {
  printf "monk auth status - Show authentication status\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth status\n"
  printf "  monk auth status --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_token_usage() {
  printf "monk auth token - Display current JWT token\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth token\n"
  printf "  monk auth token --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_auth_info_usage() {
  printf "monk auth info - Decode and display JWT token contents\n\n"

  printf "%s\n" "Usage:"
  printf "  monk auth info\n"
  printf "  monk auth info --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_data_usage() {
  printf "monk data - Data operations on dynamic schemas\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data COMMAND\n"
  printf "  monk data [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   List all records for schema\n" "list  "
  printf "  %s   Get specific record\n" "get   "
  printf "  %s   Create record from stdin\n" "create"
  printf "  %s   Update record from stdin\n" "update"
  printf "  %s   Delete record\n" "delete"
  printf "  %s   Export records to JSON files\n" "export"
  printf "  %s   Import JSON files as records\n" "import"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_data_list_usage() {
  printf "monk data list - List all records for schema\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data list SCHEMA\n"
  printf "  monk data list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to list records from\n"
    echo

  fi
}

# :command.usage
monk_data_get_usage() {
  printf "monk data get - Get specific record\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data get SCHEMA ID\n"
  printf "  monk data get --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name\n"
    echo

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    Record ID to retrieve\n"
    echo

  fi
}

# :command.usage
monk_data_create_usage() {
  printf "monk data create - Create record from stdin\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data create SCHEMA\n"
  printf "  monk data create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to create record in\n"
    echo

  fi
}

# :command.usage
monk_data_update_usage() {
  printf "monk data update - Update record from stdin\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data update SCHEMA ID\n"
  printf "  monk data update --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name\n"
    echo

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    Record ID to update\n"
    echo

  fi
}

# :command.usage
monk_data_delete_usage() {
  printf "monk data delete - Delete record\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data delete SCHEMA ID\n"
  printf "  monk data delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name\n"
    echo

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    Record ID to delete\n"
    echo

  fi
}

# :command.usage
monk_data_export_usage() {
  printf "monk data export - Export records to JSON files\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data export SCHEMA DIR\n"
  printf "  monk data export --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to export\n"
    echo

    # :argument.usage
    printf "  %s\n" "DIR"
    printf "    Directory to export to\n"
    echo

  fi
}

# :command.usage
monk_data_import_usage() {
  printf "monk data import - Import JSON files as records\n\n"

  printf "%s\n" "Usage:"
  printf "  monk data import SCHEMA DIR\n"
  printf "  monk data import --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema name to import into\n"
    echo

    # :argument.usage
    printf "  %s\n" "DIR"
    printf "    Directory to import from\n"
    echo

  fi
}

# :command.usage
monk_meta_usage() {
  printf "monk meta - Schema and metadata management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk meta COMMAND\n"
  printf "  monk meta [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   List all schemas\n" "list  "
  printf "  %s   Get specific schema\n" "get   "
  printf "  %s   Create schema from stdin (YAML/JSON)\n" "create"
  printf "  %s   Update schema from stdin\n" "update"
  printf "  %s   Delete schema\n" "delete"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_meta_list_usage() {
  printf "monk meta list - List all schemas\n\n"

  printf "%s\n" "Usage:"
  printf "  monk meta list [TYPE]\n"
  printf "  monk meta list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TYPE"
    printf "    Type to list\n"
    printf "    %s\n" "Default: schema"
    echo

  fi
}

# :command.usage
monk_meta_get_usage() {
  printf "monk meta get - Get specific schema\n\n"

  printf "%s\n" "Usage:"
  printf "  monk meta get TYPE NAME\n"
  printf "  monk meta get --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TYPE"
    printf "    Type to get\n"
    echo

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Schema name to retrieve\n"
    echo

  fi
}

# :command.usage
monk_meta_create_usage() {
  printf "monk meta create - Create schema from stdin (YAML/JSON)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk meta create TYPE\n"
  printf "  monk meta create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TYPE"
    printf "    Type to create\n"
    echo

  fi
}

# :command.usage
monk_meta_update_usage() {
  printf "monk meta update - Update schema from stdin\n\n"

  printf "%s\n" "Usage:"
  printf "  monk meta update TYPE NAME\n"
  printf "  monk meta update --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TYPE"
    printf "    Type to update\n"
    echo

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Schema name to update\n"
    echo

  fi
}

# :command.usage
monk_meta_delete_usage() {
  printf "monk meta delete - Delete schema\n\n"

  printf "%s\n" "Usage:"
  printf "  monk meta delete TYPE NAME\n"
  printf "  monk meta delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "TYPE"
    printf "    Type to delete\n"
    echo

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Schema name to delete\n"
    echo

  fi
}

# :command.usage
monk_find_usage() {
  printf "monk find - Advanced search with filter DSL\n\n"

  printf "%s\n" "Usage:"
  printf "  monk find SCHEMA [FILTERS]\n"
  printf "  monk find --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "SCHEMA"
    printf "    Schema to search\n"
    echo

    # :argument.usage
    printf "  %s\n" "FILTERS"
    printf "    JSON filter criteria (optional)\n"
    echo

  fi
}

# :command.usage
monk_ping_usage() {
  printf "monk ping - Server connectivity testing\n\n"

  printf "%s\n" "Usage:"
  printf "  monk ping [OPTIONS]\n"
  printf "  monk ping --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--verbose, -v"
    printf "    Verbose server information\n"
    echo

    # :flag.usage
    printf "  %s\n" "--jwt-token, -j TOKEN"
    printf "    Include JWT token in request\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_test_usage() {
  printf "monk test - Comprehensive test management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk test COMMAND\n"
  printf "  monk test [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Run tests (all or pattern matching)\n" "all "
  printf "  %s   Create/update git-aware test environment\n" "git "
  printf "  %s   Compare test results between environments\n" "diff"
  printf "  %s   Show test environment variables\n" "env "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_test_all_usage() {
  printf "monk test all - Run tests (all or pattern matching)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk test all [PATTERN]\n"
  printf "  monk test all --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "PATTERN"
    printf "    Pattern to match tests (e.g., 00-20)\n"
    echo

  fi
}

# :command.usage
monk_test_git_usage() {
  printf "monk test git - Create/update git-aware test environment\n\n"

  printf "%s\n" "Usage:"
  printf "  monk test git BRANCH [COMMIT]\n"
  printf "  monk test git --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "BRANCH"
    printf "    Git branch or reference\n"
    echo

    # :argument.usage
    printf "  %s\n" "COMMIT"
    printf "    Specific commit (optional)\n"
    echo

  fi
}

# :command.usage
monk_test_diff_usage() {
  printf "monk test diff - Compare test results between environments\n\n"

  printf "%s\n" "Usage:"
  printf "  monk test diff RUN1 RUN2\n"
  printf "  monk test diff --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "RUN1"
    printf "    First test run to compare\n"
    echo

    # :argument.usage
    printf "  %s\n" "RUN2"
    printf "    Second test run to compare\n"
    echo

  fi
}

# :command.usage
monk_test_env_usage() {
  printf "monk test env - Show test environment variables\n\n"

  printf "%s\n" "Usage:"
  printf "  monk test env [VAR_NAME]\n"
  printf "  monk test env --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "VAR_NAME"
    printf "    Specific variable name (optional)\n"
    echo

  fi
}

# :command.usage
monk_pool_usage() {
  printf "monk pool - Database pool management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk pool COMMAND\n"
  printf "  monk pool [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Show database pool status (X/10)\n" "status     "
  printf "  %s   List all active test databases\n" "list       "
  printf "  %s   Clean up old databases (default: over 24 hours)\n" "cleanup    "
  printf "  %s   Clean up all databases\n" "cleanup-all"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_pool_status_usage() {
  printf "monk pool status - Show database pool status (X/10)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk pool status\n"
  printf "  monk pool status --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_pool_list_usage() {
  printf "monk pool list - List all active test databases\n\n"

  printf "%s\n" "Usage:"
  printf "  monk pool list\n"
  printf "  monk pool list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_pool_cleanup_usage() {
  printf "monk pool cleanup - Clean up old databases (default: over 24 hours)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk pool cleanup [HOURS]\n"
  printf "  monk pool cleanup --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "HOURS"
    printf "    Age threshold in hours (default: 24)\n"
    echo

  fi
}

# :command.usage
monk_pool_cleanup_all_usage() {
  printf "monk pool cleanup-all - Clean up all databases\n\n"

  printf "%s\n" "Usage:"
  printf "  monk pool cleanup-all\n"
  printf "  monk pool cleanup-all --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_servers_usage() {
  printf "monk servers - Remote server management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk servers COMMAND\n"
  printf "  monk servers [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Register remote server\n" "add     "
  printf "  %s   List all servers with health status\n" "list    "
  printf "  %s   Show currently selected server\n" "current "
  printf "  %s   Switch to server (sets CLI_BASE_URL)\n" "use     "
  printf "  %s   Remove server from registry\n" "delete  "
  printf "  %s   Health check specific server\n" "ping    "
  printf "  %s   Health check all registered servers\n" "ping-all"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_servers_add_usage() {
  printf "monk servers add - Register remote server\n\n"

  printf "%s\n" "Usage:"
  printf "  monk servers add NAME ENDPOINT [OPTIONS]\n"
  printf "  monk servers add --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--description DESCRIPTION"
    printf "    Optional server description\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name\n"
    echo

    # :argument.usage
    printf "  %s\n" "ENDPOINT"
    printf "    Server endpoint (host:port)\n"
    echo

  fi
}

# :command.usage
monk_servers_list_usage() {
  printf "monk servers list - List all servers with health status\n\n"

  printf "%s\n" "Usage:"
  printf "  monk servers list\n"
  printf "  monk servers list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_servers_current_usage() {
  printf "monk servers current - Show currently selected server\n\n"

  printf "%s\n" "Usage:"
  printf "  monk servers current\n"
  printf "  monk servers current --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_servers_use_usage() {
  printf "monk servers use - Switch to server (sets CLI_BASE_URL)\n\n"

  printf "%s\n" "Usage:"
  printf "  monk servers use NAME\n"
  printf "  monk servers use --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name to switch to\n"
    echo

  fi
}

# :command.usage
monk_servers_delete_usage() {
  printf "monk servers delete - Remove server from registry\n\n"

  printf "%s\n" "Usage:"
  printf "  monk servers delete NAME\n"
  printf "  monk servers delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name to delete\n"
    echo

  fi
}

# :command.usage
monk_servers_ping_usage() {
  printf "monk servers ping - Health check specific server\n\n"

  printf "%s\n" "Usage:"
  printf "  monk servers ping NAME\n"
  printf "  monk servers ping --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Server name to ping\n"
    echo

  fi
}

# :command.usage
monk_servers_ping_all_usage() {
  printf "monk servers ping-all - Health check all registered servers\n\n"

  printf "%s\n" "Usage:"
  printf "  monk servers ping-all\n"
  printf "  monk servers ping-all --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_tenant_usage() {
  printf "monk tenant - Multi-tenant database management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant COMMAND\n"
  printf "  monk tenant [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Create new tenant database and record\n" "create"
  printf "  %s   Delete tenant database\n" "delete"
  printf "  %s   Truncate and re-initialize tenant database\n" "init  "
  printf "  %s   List all tenant databases\n" "list  "
  printf "  %s   Switch to tenant database\n" "use   "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_tenant_create_usage() {
  printf "monk tenant create - Create new tenant database and record\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant create NAME [TEST_SUFFIX] [OPTIONS]\n"
  printf "  monk tenant create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--host HOST"
    printf "    Database host\n"
    printf "    %s\n" "Default: localhost"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Name of the tenant database to create\n"
    echo

    # :argument.usage
    printf "  %s\n" "TEST_SUFFIX"
    printf "    Optional test suffix for test allocations\n"
    echo

  fi
}

# :command.usage
monk_tenant_delete_usage() {
  printf "monk tenant delete - Delete tenant database\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant delete NAME\n"
  printf "  monk tenant delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Name of the tenant database to delete\n"
    echo

  fi
}

# :command.usage
monk_tenant_init_usage() {
  printf "monk tenant init - Truncate and re-initialize tenant database\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant init NAME\n"
  printf "  monk tenant init --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Name of the existing tenant database to re-initialize\n"
    echo

  fi
}

# :command.usage
monk_tenant_list_usage() {
  printf "monk tenant list - List all tenant databases\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant list\n"
  printf "  monk tenant list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_tenant_use_usage() {
  printf "monk tenant use - Switch to tenant database\n\n"

  printf "%s\n" "Usage:"
  printf "  monk tenant use NAME\n"
  printf "  monk tenant use --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "NAME"
    printf "    Name of the tenant to switch to\n"
    echo

  fi
}

# :command.usage
monk_user_usage() {
  printf "monk user - User management and access control\n\n"

  printf "%s\n" "Usage:"
  printf "  monk user COMMAND\n"
  printf "  monk user [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   List all users\n" "list       "
  printf "  %s   Get specific user\n" "get        "
  printf "  %s   Create user from stdin\n" "create     "
  printf "  %s   Update user from stdin\n" "update     "
  printf "  %s   Delete user\n" "delete     "
  printf "  %s   Manage user permissions\n" "permissions"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_user_list_usage() {
  printf "monk user list - List all users\n\n"

  printf "%s\n" "Usage:"
  printf "  monk user list\n"
  printf "  monk user list --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_user_get_usage() {
  printf "monk user get - Get specific user\n\n"

  printf "%s\n" "Usage:"
  printf "  monk user get ID\n"
  printf "  monk user get --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    User ID to retrieve\n"
    echo

  fi
}

# :command.usage
monk_user_create_usage() {
  printf "monk user create - Create user from stdin\n\n"

  printf "%s\n" "Usage:"
  printf "  monk user create\n"
  printf "  monk user create --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_user_update_usage() {
  printf "monk user update - Update user from stdin\n\n"

  printf "%s\n" "Usage:"
  printf "  monk user update ID\n"
  printf "  monk user update --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    User ID to update\n"
    echo

  fi
}

# :command.usage
monk_user_delete_usage() {
  printf "monk user delete - Delete user\n\n"

  printf "%s\n" "Usage:"
  printf "  monk user delete ID\n"
  printf "  monk user delete --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    User ID to delete\n"
    echo

  fi
}

# :command.usage
monk_user_permissions_usage() {
  printf "monk user permissions - Manage user permissions\n\n"

  printf "%s\n" "Usage:"
  printf "  monk user permissions ID\n"
  printf "  monk user permissions --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

    # :command.usage_args
    printf "%s\n" "Arguments:"

    # :argument.usage
    printf "  %s\n" "ID"
    printf "    User ID to manage permissions for\n"
    echo

  fi
}

# :command.usage
monk_root_usage() {
  printf "monk root - System administration\n\n"

  printf "%s\n" "Usage:"
  printf "  monk root COMMAND\n"
  printf "  monk root [COMMAND] --help | -h\n"
  echo
  # :command.usage_commands
  printf "%s\n" "Commands:"
  printf "  %s   Show system status and health\n" "status "
  printf "  %s   System configuration management\n" "config "
  printf "  %s   Domain and database management\n" "domains"
  printf "  %s   System cleanup and maintenance\n" "cleanup"
  printf "  %s   Backup and restore operations\n" "backup "
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_root_status_usage() {
  printf "monk root status - Show system status and health\n\n"

  printf "%s\n" "Usage:"
  printf "  monk root status\n"
  printf "  monk root status --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_root_config_usage() {
  printf "monk root config - System configuration management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk root config\n"
  printf "  monk root config --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_root_domains_usage() {
  printf "monk root domains - Domain and database management\n\n"

  printf "%s\n" "Usage:"
  printf "  monk root domains\n"
  printf "  monk root domains --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_root_cleanup_usage() {
  printf "monk root cleanup - System cleanup and maintenance\n\n"

  printf "%s\n" "Usage:"
  printf "  monk root cleanup\n"
  printf "  monk root cleanup --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.usage
monk_root_backup_usage() {
  printf "monk root backup - Backup and restore operations\n\n"

  printf "%s\n" "Usage:"
  printf "  monk root backup\n"
  printf "  monk root backup --help | -h\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    printf "%s\n" "Options:"

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/common.sh
#!/bin/bash

# Common functions for bashly CLI commands
# This file contains shared functionality migrated from cli/common.sh

# JWT token storage file
JWT_TOKEN_FILE="${HOME}/.monk-jwt-token"

# Servers configuration file
SERVERS_CONFIG="${HOME}/.config/monk/servers.json"

# Default configuration
DEFAULT_BASE_URL="http://localhost:3000"
DEFAULT_LIMIT=50
DEFAULT_FORMAT="raw"

# Colors for output formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Print colored output
print_error() {
    echo -e "${RED}✗ $1${NC}" >&2
}

print_success() {
    echo -e "${GREEN}✓ $1${NC}"
}

print_info() {
    echo -e "${YELLOW}ℹ $1${NC}"
}

print_warning() {
    echo -e "${YELLOW}⚠ $1${NC}"
}

# Get base URL from servers config - fail if not configured
get_base_url() {
    local servers_config="${HOME}/.config/monk/servers.json"

    # Check if jq is available
    if ! command -v jq >/dev/null 2>&1; then
        echo "Error: jq is required for server configuration" >&2
        echo "Install jq to use server configuration" >&2
        exit 1
    fi

    # Check if config file exists
    if [[ ! -f "$servers_config" ]]; then
        echo "Error: No server configuration found" >&2
        echo "Use 'monk servers add <name> <hostname:port>' to add a server" >&2
        exit 1
    fi

    # Get current server
    local current_server
    current_server=$(jq -r '.current // empty' "$servers_config" 2>/dev/null)

    if [[ -z "$current_server" || "$current_server" == "null" ]]; then
        echo "Error: No current server selected" >&2
        echo "Use 'monk servers use <name>' to select a server" >&2
        exit 1
    fi

    # Get server info
    local server_info
    server_info=$(jq -r ".servers.\"$current_server\"" "$servers_config" 2>/dev/null)

    if [[ "$server_info" == "null" ]]; then
        echo "Error: Current server '$current_server' not found in configuration" >&2
        echo "Use 'monk servers list' to see available servers" >&2
        exit 1
    fi

    # Extract connection details
    local hostname=$(echo "$server_info" | jq -r '.hostname')
    local port=$(echo "$server_info" | jq -r '.port')
    local protocol=$(echo "$server_info" | jq -r '.protocol')

    # Validate required fields
    if [[ "$hostname" == "null" || "$port" == "null" || "$protocol" == "null" ]]; then
        echo "Error: Invalid server configuration for '$current_server'" >&2
        echo "Server configuration is missing required fields (hostname, port, protocol)" >&2
        exit 1
    fi

    echo "$protocol://$hostname:$port"
}

# Get stored JWT token for current server
get_jwt_token() {
    init_servers_config

    if ! command -v jq >/dev/null 2>&1; then
        # Fallback to old global token file if jq not available
        if [ -f "$JWT_TOKEN_FILE" ]; then
            cat "$JWT_TOKEN_FILE"
        fi
        return
    fi

    # Get current server name
    local current_server
    current_server=$(jq -r '.current // empty' "$SERVERS_CONFIG" 2>/dev/null)

    if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
        # No current server, try fallback to global token
        if [ -f "$JWT_TOKEN_FILE" ]; then
            cat "$JWT_TOKEN_FILE"
        fi
        return
    fi

    # Get server-specific token
    local token
    token=$(jq -r ".servers.\"$current_server\".jwt_token // empty" "$SERVERS_CONFIG" 2>/dev/null)

    if [ -n "$token" ] && [ "$token" != "null" ]; then
        echo "$token"
    fi
}

# Store JWT token for current server
store_token() {
    local token="$1"

    init_servers_config

    if ! command -v jq >/dev/null 2>&1; then
        # Fallback to old global token file if jq not available
        echo "$token" > "$JWT_TOKEN_FILE"
        chmod 600 "$JWT_TOKEN_FILE"
        return
    fi

    # Get current server name
    local current_server
    current_server=$(jq -r '.current // empty' "$SERVERS_CONFIG" 2>/dev/null)

    if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
        # No current server, store in global file as fallback
        echo "$token" > "$JWT_TOKEN_FILE"
        chmod 600 "$JWT_TOKEN_FILE"
        return
    fi

    # Store token in server configuration
    local temp_file=$(mktemp)
    jq --arg server "$current_server" \
       --arg token "$token" \
       '.servers[$server].jwt_token = $token' \
       "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"

    # Set secure permissions on config file
    chmod 600 "$SERVERS_CONFIG"
}

# Remove stored JWT token for current server
remove_stored_token() {
    init_servers_config

    if ! command -v jq >/dev/null 2>&1; then
        # Fallback to old global token file if jq not available
        rm -f "$JWT_TOKEN_FILE"
        return
    fi

    # Get current server name
    local current_server
    current_server=$(jq -r '.current // empty' "$SERVERS_CONFIG" 2>/dev/null)

    if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
        # No current server, remove global file as fallback
        rm -f "$JWT_TOKEN_FILE"
        return
    fi

    # Remove token from server configuration
    local temp_file=$(mktemp)
    jq --arg server "$current_server" \
       'del(.servers[$server].jwt_token)' \
       "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"
}

# Make HTTP request and handle response - programmatic by default
make_request() {
    local method="$1"
    local url="$2"
    local data="$3"
    local base_url=$(get_base_url)
    local full_url="${base_url}${url}"

    # Only show verbose info if CLI_VERBOSE is set
    if [ "$CLI_VERBOSE" = "true" ]; then
        print_info "Making $method request to: $full_url" >&2
    fi

    local curl_args=(-s -X "$method" -H "Content-Type: application/json")

    # Add JWT token if available (unless it's an auth request)
    if [[ "$url" != "/auth/"* ]]; then
        local jwt_token
        jwt_token=$(get_jwt_token)
        if [ -n "$jwt_token" ]; then
            curl_args+=(-H "Authorization: Bearer $jwt_token")
            if [ "$CLI_VERBOSE" = "true" ]; then
                print_info "Using stored JWT token" >&2
            fi
        fi
    fi

    if [ -n "$data" ]; then
        curl_args+=(-d "$data")
    fi

    local response
    local http_code

    # Make request and capture both response and HTTP status code
    response=$(curl "${curl_args[@]}" -w "\n%{http_code}" "$full_url")
    http_code=$(echo "$response" | tail -n1)
    response=$(echo "$response" | sed '$d')

    # Handle HTTP errors
    case "$http_code" in
        200|201)
            if [ "$CLI_VERBOSE" = "true" ]; then
                print_success "Success ($http_code)" >&2
            fi
            # Return response without formatting - let caller handle it
            echo "$response"
            return 0
            ;;
        400|404|500)
            if [ "$CLI_VERBOSE" = "true" ]; then
                print_error "HTTP Error ($http_code)" >&2
            fi
            echo "$response" >&2
            exit 1
            ;;
        *)
            if [ "$CLI_VERBOSE" = "true" ]; then
                print_error "HTTP $http_code" >&2
            fi
            echo "$response" >&2
            exit 1
            ;;
    esac
}

# Handle response based on CLI flags - optimized for testing
handle_response() {
    local response="$1"
    local operation_type="$2"  # "list", "create", "get", etc.

    # Exit code only mode - no output, just exit status
    if [ "$CLI_EXIT_CODE_ONLY" = "true" ]; then
        if echo "$response" | grep -q '"success":true'; then
            exit 0
        else
            exit 1
        fi
    fi

    # Count mode for list operations
    if [ "$CLI_COUNT_MODE" = "true" ] && [ "$operation_type" = "list" ]; then
        if [ "$JSON_PARSER" = "jq" ]; then
            echo "$response" | jq '.data | length' 2>/dev/null || echo "0"
        elif [ "$JSON_PARSER" = "jshon" ]; then
            echo "$response" | jshon -e data -l 2>/dev/null || echo "0"
        else
            echo "$response"
        fi
        return
    fi

    # Field extraction mode
    if [ -n "$CLI_FORMAT" ]; then
        if [ "$JSON_PARSER" = "jq" ]; then
            # Handle both single objects and arrays
            if echo "$response" | jq -e '.data | type == "array"' >/dev/null 2>&1; then
                # Array case - extract field from each item
                echo "$response" | jq -r ".data[].${CLI_FORMAT}" 2>/dev/null || {
                    if [ "$CLI_VERBOSE" = "true" ]; then
                        print_error "Failed to extract field: $CLI_FORMAT" >&2
                    fi
                    exit 1
                }
            else
                # Single object case - extract field directly
                echo "$response" | jq -r ".data.${CLI_FORMAT}" 2>/dev/null || {
                    if [ "$CLI_VERBOSE" = "true" ]; then
                        print_error "Failed to extract field: $CLI_FORMAT" >&2
                    fi
                    exit 1
                }
            fi
        elif [ "$JSON_PARSER" = "jshon" ]; then
            echo "$response" | jshon -e data -e "$CLI_FORMAT" -u 2>/dev/null || {
                if [ "$CLI_VERBOSE" = "true" ]; then
                    print_error "Failed to extract field: $CLI_FORMAT" >&2
                fi
                exit 1
            }
        else
            if [ "$CLI_VERBOSE" = "true" ]; then
                print_error "jq or jshon required for field extraction" >&2
            fi
            exit 1
        fi
        return
    fi

    # Default: auto-extract 'data' property for cleaner output
    if [ "$JSON_PARSER" = "jq" ]; then
        # Check if response has success:true and extract data
        if echo "$response" | jq -e '.success' >/dev/null 2>&1; then
            if echo "$response" | jq -e '.success == true' >/dev/null 2>&1; then
                # Success response - extract data
                echo "$response" | jq '.data'
            else
                # Error response - show full response for debugging
                echo "$response"
            fi
        else
            # Not a standard API response - show raw
            echo "$response"
        fi
    elif [ "$JSON_PARSER" = "jshon" ]; then
        # Check if response has success:true and extract data
        if echo "$response" | jshon -e success -u 2>/dev/null | grep -q "true"; then
            echo "$response" | jshon -e data 2>/dev/null || echo "$response"
        else
            echo "$response"
        fi
    else
        # No JSON parser - raw output
        echo "$response"
    fi
}

# Validate required arguments
require_args() {
    local required_count="$1"
    local actual_count="$2"
    local usage="$3"

    if [ "$actual_count" -lt "$required_count" ]; then
        print_error "Missing required arguments"
        print_info "Usage: $usage"
        exit 1
    fi
}

# Check dependencies - keep it simple
check_dependencies() {
    if ! command -v curl &> /dev/null; then
        print_error "curl is required but not installed."
        exit 1
    fi

    # Check for JSON parser for extraction operations (prefer jq over jshon)
    if command -v jq &> /dev/null; then
        export JSON_PARSER="jq"
    elif command -v jshon &> /dev/null; then
        export JSON_PARSER="jshon"
    else
        export JSON_PARSER="none"
    fi
}

# Initialize servers config if it doesn't exist
init_servers_config() {
    # Ensure config directory exists
    mkdir -p "$(dirname "$SERVERS_CONFIG")"

    if [ ! -f "$SERVERS_CONFIG" ]; then
        cat > "$SERVERS_CONFIG" << 'EOF'
{
  "servers": {},
  "current": null
}
EOF
    fi
}

# Parse hostname:port into components
parse_endpoint() {
    local endpoint="$1"
    local hostname=""
    local port=""
    local protocol=""

    # Handle protocol prefixes
    if echo "$endpoint" | grep -q "^https://"; then
        protocol="https"
        endpoint=$(echo "$endpoint" | sed 's|^https://||')
    elif echo "$endpoint" | grep -q "^http://"; then
        protocol="http"
        endpoint=$(echo "$endpoint" | sed 's|^http://||')
    fi

    # Parse hostname:port
    if echo "$endpoint" | grep -q ":"; then
        hostname=$(echo "$endpoint" | cut -d':' -f1)
        port=$(echo "$endpoint" | cut -d':' -f2)
    else
        hostname="$endpoint"
        port="80"
    fi

    # Auto-detect protocol if not specified
    if [ -z "$protocol" ]; then
        if [ "$port" = "443" ]; then
            protocol="https"
        else
            protocol="http"
        fi
    fi

    echo "$protocol|$hostname|$port"
}

# Health check a server URL
ping_server_url() {
    local base_url="$1"
    local timeout="${2:-5}"

    # Try to ping the /ping endpoint with a short timeout
    if curl -s --max-time "$timeout" --fail "$base_url/ping" >/dev/null 2>&1; then
        return 0
    elif curl -s --max-time "$timeout" --fail "$base_url/" >/dev/null 2>&1; then
        return 0
    else
        return 1
    fi
}

# Initialize tenant database schema
init_tenant_schema() {
    local tenant_name="$1"
    local db_user="${2:-$(whoami)}"

    # Find the schema file relative to the CLI root
    local schema_file=""

    # Try different possible locations for the schema file
    if [ -f "../sql/init-tenant.sql" ]; then
        schema_file="../sql/init-tenant.sql"
    elif [ -f "../../sql/init-tenant.sql" ]; then
        schema_file="../../sql/init-tenant.sql"
    elif [ -f "sql/init-tenant.sql" ]; then
        schema_file="sql/init-tenant.sql"
    else
        print_error "Schema file not found: init-tenant.sql"
        return 1
    fi

    print_info "Initializing tenant database schema..."
    if psql -U "$db_user" -d "$tenant_name" -f "$schema_file" >/dev/null 2>&1; then
        print_success "Tenant database schema initialized"
        return 0
    else
        print_error "Failed to initialize tenant database schema"
        return 1
    fi
}

# :command.command_functions

# :command.function
monk_auth_login_command() {

  # src/auth_login_command.sh
  # Check dependencies
  check_dependencies

  # Extract domain from bashly args
  domain="${args[--domain]}"

  if [ "$CLI_VERBOSE" = "true" ]; then
      print_info "Authenticating with domain: $domain"
  fi

  # Prepare authentication request
  auth_data="{\"domain\": \"$domain\"}"
  base_url=$(get_base_url)

  if [ "$CLI_VERBOSE" = "true" ]; then
      print_info "Sending authentication request to: ${base_url}/auth/login"
  fi

  # Make authentication request
  if response=$(make_request "POST" "/auth/login" "$auth_data"); then
      # Extract token from response
      token=""
      if [ "$JSON_PARSER" = "jq" ]; then
          token=$(echo "$response" | jq -r '.data.token' 2>/dev/null)
      elif [ "$JSON_PARSER" = "jshon" ]; then
          token=$(echo "$response" | jshon -e data -e token -u 2>/dev/null)
      else
          # Fallback: extract token manually
          token=$(echo "$response" | grep -o '"token":"[^"]*"' | cut -d'"' -f4)
      fi

      if [ -n "$token" ] && [ "$token" != "null" ]; then
          # Store token
          store_token "$token"

          print_success "Authentication successful"

          if [ "$CLI_VERBOSE" = "true" ]; then
              print_info "JWT token stored in: $JWT_TOKEN_FILE"
          fi
      else
          print_error "Failed to extract JWT token from response"
          if [ "$CLI_VERBOSE" = "true" ]; then
              print_info "Response: $response"
          fi
          exit 1
      fi
  else
      print_error "Authentication failed"
      exit 1
  fi
}

# :command.function
monk_auth_logout_command() {

  # src/auth_logout_command.sh
  if [ -f "$JWT_TOKEN_FILE" ]; then
      remove_stored_token
      print_success "Logged out successfully"
  else
      print_info "Already logged out"
  fi
}

# :command.function
monk_auth_status_command() {

  # src/auth_status_command.sh
  token=$(get_jwt_token)

  if [ -n "$token" ]; then
      print_success "Authenticated"

      # Try to extract domain from token (basic decode)
      if [ "$JSON_PARSER" = "jq" ] || [ "$JSON_PARSER" = "jshon" ]; then
          # Decode JWT payload (basic base64 decode of middle part)
          payload=$(echo "$token" | cut -d'.' -f2)
          # Add padding if needed
          case $((${#payload} % 4)) in
              2) payload="${payload}==" ;;
              3) payload="${payload}=" ;;
          esac

          if command -v base64 &> /dev/null; then
              decoded=$(echo "$payload" | base64 -d 2>/dev/null || echo "")
              if [ -n "$decoded" ]; then
                  if [ "$JSON_PARSER" = "jq" ]; then
                      domain=$(echo "$decoded" | jq -r '.domain' 2>/dev/null || echo "unknown")
                      exp=$(echo "$decoded" | jq -r '.exp' 2>/dev/null || echo "unknown")
                  elif [ "$JSON_PARSER" = "jshon" ]; then
                      domain=$(echo "$decoded" | jshon -e domain -u 2>/dev/null || echo "unknown")
                      exp=$(echo "$decoded" | jshon -e exp -u 2>/dev/null || echo "unknown")
                  fi

                  echo "Domain: $domain"
                  if [ "$exp" != "unknown" ] && [ "$exp" != "null" ]; then
                      if command -v date &> /dev/null; then
                          exp_date=$(date -r "$exp" 2>/dev/null || echo "unknown")
                          echo "Expires: $exp_date"
                      fi
                  fi
              fi
          fi
      fi

      echo "Token file: $JWT_TOKEN_FILE"
  else
      print_info "Not authenticated"
      echo "Use 'monk auth login --domain DOMAIN' to authenticate"
  fi
}

# :command.function
monk_auth_token_command() {

  # src/auth_token_command.sh
  token=$(get_jwt_token)

  if [ -n "$token" ]; then
      echo "$token"
  else
      print_error "No token found. Use 'monk auth login --domain DOMAIN' first"
      exit 1
  fi
}

# :command.function
monk_auth_info_command() {

  # src/auth_info_command.sh
  token=$(get_jwt_token)

  if [ -z "$token" ]; then
      print_error "No authentication token found"
      print_info "Use 'monk auth login --domain DOMAIN' to authenticate"
      exit 1
  fi

  # Extract payload (second part) from JWT
  payload=$(echo "$token" | cut -d'.' -f2)

  # Add padding if needed for base64 decoding
  padding=$((4 - ${#payload} % 4))
  if [ $padding -ne 4 ]; then
      payload="${payload}$(printf '%*s' $padding '' | tr ' ' '=')"
  fi

  # Decode base64 payload
  if command -v base64 >/dev/null 2>&1; then
      decoded=$(echo "$payload" | base64 -d 2>/dev/null || echo "")
  else
      print_error "base64 command not found"
      exit 1
  fi

  if [ -n "$decoded" ]; then
      print_success "JWT Token Information:"
      echo

      # Pretty print JSON if jq is available
      if command -v jq >/dev/null 2>&1; then
          echo "$decoded" | jq .
      else
          echo "$decoded"
      fi

      echo
      if command -v jq >/dev/null 2>&1; then
          exp_timestamp=$(echo "$decoded" | jq -r '.exp' 2>/dev/null)
          if [ "$exp_timestamp" != "null" ] && [ -n "$exp_timestamp" ]; then
              exp_date=$(date -r "$exp_timestamp" 2>/dev/null || echo 'unknown')
              print_info "Token expires: $exp_date"
          fi
      fi
  else
      print_error "Failed to decode JWT token"
      exit 1
  fi
}

# :command.function
monk_data_list_command() {

  # src/data_list_command.sh
  echo "# This file is located at 'src/data_list_command.sh'."
  echo "# It contains the implementation for the 'monk data list' command."
  echo "# The code you write here will be wrapped by a function named 'monk_data_list_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_data_get_command() {

  # src/data_get_command.sh
  echo "# This file is located at 'src/data_get_command.sh'."
  echo "# It contains the implementation for the 'monk data get' command."
  echo "# The code you write here will be wrapped by a function named 'monk_data_get_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_data_create_command() {

  # src/data_create_command.sh
  echo "# This file is located at 'src/data_create_command.sh'."
  echo "# It contains the implementation for the 'monk data create' command."
  echo "# The code you write here will be wrapped by a function named 'monk_data_create_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_data_update_command() {

  # src/data_update_command.sh
  echo "# This file is located at 'src/data_update_command.sh'."
  echo "# It contains the implementation for the 'monk data update' command."
  echo "# The code you write here will be wrapped by a function named 'monk_data_update_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_data_delete_command() {

  # src/data_delete_command.sh
  echo "# This file is located at 'src/data_delete_command.sh'."
  echo "# It contains the implementation for the 'monk data delete' command."
  echo "# The code you write here will be wrapped by a function named 'monk_data_delete_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_data_export_command() {

  # src/data_export_command.sh
  echo "# This file is located at 'src/data_export_command.sh'."
  echo "# It contains the implementation for the 'monk data export' command."
  echo "# The code you write here will be wrapped by a function named 'monk_data_export_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_data_import_command() {

  # src/data_import_command.sh
  echo "# This file is located at 'src/data_import_command.sh'."
  echo "# It contains the implementation for the 'monk data import' command."
  echo "# The code you write here will be wrapped by a function named 'monk_data_import_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_meta_list_command() {

  # src/meta_list_command.sh
  echo "# This file is located at 'src/meta_list_command.sh'."
  echo "# It contains the implementation for the 'monk meta list' command."
  echo "# The code you write here will be wrapped by a function named 'monk_meta_list_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_meta_get_command() {

  # src/meta_get_command.sh
  echo "# This file is located at 'src/meta_get_command.sh'."
  echo "# It contains the implementation for the 'monk meta get' command."
  echo "# The code you write here will be wrapped by a function named 'monk_meta_get_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_meta_create_command() {

  # src/meta_create_command.sh
  echo "# This file is located at 'src/meta_create_command.sh'."
  echo "# It contains the implementation for the 'monk meta create' command."
  echo "# The code you write here will be wrapped by a function named 'monk_meta_create_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_meta_update_command() {

  # src/meta_update_command.sh
  echo "# This file is located at 'src/meta_update_command.sh'."
  echo "# It contains the implementation for the 'monk meta update' command."
  echo "# The code you write here will be wrapped by a function named 'monk_meta_update_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_meta_delete_command() {

  # src/meta_delete_command.sh
  echo "# This file is located at 'src/meta_delete_command.sh'."
  echo "# It contains the implementation for the 'monk meta delete' command."
  echo "# The code you write here will be wrapped by a function named 'monk_meta_delete_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_find_command() {

  # src/find_command.sh
  echo "# This file is located at 'src/find_command.sh'."
  echo "# It contains the implementation for the 'monk find' command."
  echo "# The code you write here will be wrapped by a function named 'monk_find_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_ping_command() {

  # src/ping_command.sh
  # Check dependencies
  check_dependencies

  # Get flags from bashly args
  verbose_flag="${args[--verbose]}"
  jwt_token_arg="${args[--jwt-token]}"

  # Set CLI_VERBOSE if flag is present

  if [ "$verbose_flag" = "1" ] || [ "$verbose_flag" = "true" ]; then
      CLI_VERBOSE=true
  fi

  # Make ping request
  base_url=$(get_base_url)

  if [ "$CLI_VERBOSE" = "true" ]; then
      print_info "Pinging server at: $base_url"
  fi

  # Prepare curl arguments
  curl_args=(-s -X GET -H "Content-Type: application/json")

  # Add JWT token (provided via -j flag or stored token)
  token_to_use="$jwt_token_arg"
  if [ -z "$token_to_use" ]; then
      token_to_use=$(get_jwt_token)
  fi

  if [ -n "$token_to_use" ]; then
      curl_args+=(-H "Authorization: Bearer $token_to_use")
      if [ "$CLI_VERBOSE" = "true" ]; then
          if [ -n "$jwt_token_arg" ]; then
              print_info "Using provided JWT token"
          else
              print_info "Using stored JWT token"
          fi
      fi
  fi

  # Make request
  full_url="${base_url}/ping"
  response=$(curl "${curl_args[@]}" -w "\n%{http_code}" "$full_url")
  http_code=$(echo "$response" | tail -n1)
  response=$(echo "$response" | sed '$d')

  # Handle response
  case "$http_code" in
      200)
          if [ "$CLI_VERBOSE" = "true" ]; then
              print_success "Server is reachable (HTTP $http_code)"
              echo "Response: $response"
          else
              # Parse response for clean output
              if [ "$JSON_PARSER" = "jq" ]; then
                  pong=$(echo "$response" | jq -r '.pong' 2>/dev/null || echo "unknown")
                  domain=$(echo "$response" | jq -r '.domain' 2>/dev/null || echo "null")
                  database=$(echo "$response" | jq -r '.database' 2>/dev/null || echo "null")

                  echo "pong: $pong"
                  if [ "$domain" != "null" ] && [ "$domain" != "" ]; then
                      echo "domain: $domain"
                  fi
                  if [ "$database" != "null" ] && [ "$database" != "" ]; then
                      if [ "$database" = "ok" ]; then
                          echo "database: $database"
                      else
                          echo "database: ERROR - $database"
                      fi
                  fi
              elif [ "$JSON_PARSER" = "jshon" ]; then
                  pong=$(echo "$response" | jshon -e pong -u 2>/dev/null || echo "unknown")
                  domain=$(echo "$response" | jshon -e domain -u 2>/dev/null || echo "null")
                  database=$(echo "$response" | jshon -e database -u 2>/dev/null || echo "null")

                  echo "pong: $pong"
                  if [ "$domain" != "null" ]; then
                      echo "domain: $domain"
                  fi
                  if [ "$database" != "null" ]; then
                      if [ "$database" = "ok" ]; then
                          echo "database: $database"
                      else
                          echo "database: ERROR - $database"
                      fi
                  fi
              else
                  echo "$response"
              fi
          fi
          ;;
      *)
          print_error "Server unreachable (HTTP $http_code)"
          if [ "$CLI_VERBOSE" = "true" ]; then
              echo "Response: $response" >&2
          fi
          exit 1
          ;;
  esac
}

# :command.function
monk_test_all_command() {

  # src/test_all_command.sh
  echo "# This file is located at 'src/test_all_command.sh'."
  echo "# It contains the implementation for the 'monk test all' command."
  echo "# The code you write here will be wrapped by a function named 'monk_test_all_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_test_git_command() {

  # src/test_git_command.sh
  echo "# This file is located at 'src/test_git_command.sh'."
  echo "# It contains the implementation for the 'monk test git' command."
  echo "# The code you write here will be wrapped by a function named 'monk_test_git_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_test_diff_command() {

  # src/test_diff_command.sh
  echo "# This file is located at 'src/test_diff_command.sh'."
  echo "# It contains the implementation for the 'monk test diff' command."
  echo "# The code you write here will be wrapped by a function named 'monk_test_diff_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_test_env_command() {

  # src/test_env_command.sh
  echo "# This file is located at 'src/test_env_command.sh'."
  echo "# It contains the implementation for the 'monk test env' command."
  echo "# The code you write here will be wrapped by a function named 'monk_test_env_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_pool_status_command() {

  # src/pool_status_command.sh
  echo "# This file is located at 'src/pool_status_command.sh'."
  echo "# It contains the implementation for the 'monk pool status' command."
  echo "# The code you write here will be wrapped by a function named 'monk_pool_status_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_pool_list_command() {

  # src/pool_list_command.sh
  echo "# This file is located at 'src/pool_list_command.sh'."
  echo "# It contains the implementation for the 'monk pool list' command."
  echo "# The code you write here will be wrapped by a function named 'monk_pool_list_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_pool_cleanup_command() {

  # src/pool_cleanup_command.sh
  echo "# This file is located at 'src/pool_cleanup_command.sh'."
  echo "# It contains the implementation for the 'monk pool cleanup' command."
  echo "# The code you write here will be wrapped by a function named 'monk_pool_cleanup_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_pool_cleanup_all_command() {

  # src/pool_cleanup_all_command.sh
  echo "# This file is located at 'src/pool_cleanup_all_command.sh'."
  echo "# It contains the implementation for the 'monk pool cleanup-all' command."
  echo "# The code you write here will be wrapped by a function named 'monk_pool_cleanup_all_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_servers_add_command() {

  # src/servers_add_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"
  endpoint="${args[endpoint]}"
  description="${args[--description]}"

  init_servers_config

  # Parse endpoint
  parsed=$(parse_endpoint "$endpoint")
  protocol=$(echo "$parsed" | cut -d'|' -f1)
  hostname=$(echo "$parsed" | cut -d'|' -f2)
  port=$(echo "$parsed" | cut -d'|' -f3)

  print_info "Adding server: $name"
  print_info "Endpoint: $protocol://$hostname:$port"
  if [ -n "$description" ]; then
      print_info "Description: $description"
  fi

  # Check if server already exists
  if command -v jq >/dev/null 2>&1; then
      if jq -e ".servers.\"$name\"" "$SERVERS_CONFIG" >/dev/null 2>&1; then
          print_error "Server '$name' already exists"
          print_info "Use 'monk servers delete $name' first, or choose a different name"
          exit 1
      fi
  fi

  # Test connectivity
  print_info "Testing connectivity to $protocol://$hostname:$port"
  base_url="$protocol://$hostname:$port"

  if ping_server_url "$base_url"; then
      print_success "Server is reachable"
      status="up"
  else
      print_info "Server appears to be down (this is OK, adding anyway)"
      status="down"
  fi

  # Add server to config
  timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

  if command -v jq >/dev/null 2>&1; then
      # Use jq for JSON manipulation
      temp_file=$(mktemp)
      jq --arg name "$name" \
         --arg hostname "$hostname" \
         --arg port "$port" \
         --arg protocol "$protocol" \
         --arg description "$description" \
         --arg timestamp "$timestamp" \
         --arg status "$status" \
         '.servers[$name] = {
             "hostname": $hostname,
             "port": ($port | tonumber),
             "protocol": $protocol,
             "description": $description,
             "added_at": $timestamp,
             "last_ping": $timestamp,
             "status": $status
         }' "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"

      print_success "Server '$name' added successfully"

      # If this is the first server, make it current
      server_count=$(jq '.servers | length' "$SERVERS_CONFIG")
      if [ "$server_count" -eq 1 ]; then
          jq --arg name "$name" '.current = $name' "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"
          print_info "Set as current server (first server added)"
      fi
  else
      print_error "jq is required for server management"
      print_info "Please install jq: brew install jq (macOS) or apt-get install jq (Linux)"
      exit 1
  fi
}

# :command.function
monk_servers_list_command() {

  # src/servers_list_command.sh
  # Check dependencies
  check_dependencies

  init_servers_config

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  echo
  print_info "Registered Servers"
  echo

  current_server=$(jq -r '.current // empty' "$SERVERS_CONFIG" 2>/dev/null)

  server_names=$(jq -r '.servers | keys[]' "$SERVERS_CONFIG" 2>/dev/null)

  if [ -z "$server_names" ]; then
      print_info "No servers configured"
      print_info "Use 'monk servers add <name> <hostname:port>' to add servers"
      exit 0
  fi

  printf "%-15s %-30s %-8s %-12s %-20s %s\n" "Name" "Endpoint" "Status" "Last Ping" "Added" "Description"
  echo "--------------------------------------------------------------------------------------------------------"

  echo "$server_names" | while read -r name; do
      if [ -n "$name" ]; then
          server_info=$(jq -r ".servers.\"$name\"" "$SERVERS_CONFIG")

          hostname=$(echo "$server_info" | jq -r '.hostname')
          port=$(echo "$server_info" | jq -r '.port')
          protocol=$(echo "$server_info" | jq -r '.protocol')
          status=$(echo "$server_info" | jq -r '.status // "unknown"')
          last_ping=$(echo "$server_info" | jq -r '.last_ping // "never"')
          added_at=$(echo "$server_info" | jq -r '.added_at // "unknown"')
          description=$(echo "$server_info" | jq -r '.description // ""')

          endpoint="$protocol://$hostname:$port"

          # Format timestamps
          if [ "$last_ping" != "never" ] && [ "$last_ping" != "unknown" ]; then
              last_ping=$(echo "$last_ping" | cut -d'T' -f1)
          fi
          if [ "$added_at" != "unknown" ]; then
              added_at=$(echo "$added_at" | cut -d'T' -f1)
          fi

          # Mark current server
          marker=""
          if [ "$name" = "$current_server" ]; then
              marker="*"
          fi

          printf "%-15s %-30s %-8s %-12s %-20s %s %s\n" \
              "$name" "$endpoint" "$status" "$last_ping" "$added_at" "$description" "$marker"
      fi
  done

  echo
  if [ -n "$current_server" ]; then
      print_info "Current server: $current_server (marked with *)"
  else
      print_info "No current server selected"
      print_info "Use 'monk servers use <name>' to select a server"
  fi
}

# :command.function
monk_servers_current_command() {

  # src/servers_current_command.sh
  # Check dependencies
  check_dependencies

  init_servers_config

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  current_server=$(jq -r '.current // empty' "$SERVERS_CONFIG" 2>/dev/null)

  if [ -z "$current_server" ] || [ "$current_server" = "null" ]; then
      print_info "No current server selected"
      print_info "Use 'monk servers use <name>' to select a server"
      exit 0
  fi

  server_info=$(jq -r ".servers.\"$current_server\"" "$SERVERS_CONFIG" 2>/dev/null)
  if [ "$server_info" = "null" ]; then
      print_error "Current server '$current_server' not found in registry"
      print_info "The server may have been deleted. Use 'monk servers list' to see available servers"
      exit 1
  fi

  echo
  print_info "Current Server"
  echo

  hostname=$(echo "$server_info" | jq -r '.hostname')
  port=$(echo "$server_info" | jq -r '.port')
  protocol=$(echo "$server_info" | jq -r '.protocol')
  status=$(echo "$server_info" | jq -r '.status // "unknown"')
  description=$(echo "$server_info" | jq -r '.description // ""')

  echo "Name: $current_server"
  echo "Endpoint: $protocol://$hostname:$port"
  echo "Status: $status"
  if [ -n "$description" ]; then
      echo "Description: $description"
  fi

  # Show calculated base URL
  base_url="$protocol://$hostname:$port"
  echo "Base URL: $base_url"
}

# :command.function
monk_servers_use_command() {

  # src/servers_use_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  init_servers_config

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # Check if server exists
  server_info=$(jq -r ".servers.\"$name\"" "$SERVERS_CONFIG" 2>/dev/null)
  if [ "$server_info" = "null" ]; then
      print_error "Server '$name' not found"
      print_info "Use 'monk servers list' to see available servers"
      exit 1
  fi

  # Set as current server
  temp_file=$(mktemp)
  jq --arg name "$name" '.current = $name' "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"

  # Get server details for confirmation
  hostname=$(echo "$server_info" | jq -r '.hostname')
  port=$(echo "$server_info" | jq -r '.port')
  protocol=$(echo "$server_info" | jq -r '.protocol')
  base_url="$protocol://$hostname:$port"

  print_success "Switched to server: $name"
  print_info "Endpoint: $base_url"
  print_info "All monk commands will now use this server"
  print_info "Base URL: $base_url"
}

# :command.function
monk_servers_delete_command() {

  # src/servers_delete_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  init_servers_config

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # Check if server exists
  if ! jq -e ".servers.\"$name\"" "$SERVERS_CONFIG" >/dev/null 2>&1; then
      print_error "Server '$name' not found"
      print_info "Use 'monk servers list' to see available servers"
      exit 1
  fi

  print_info "Deleting server: $name"

  # Remove server from config
  temp_file=$(mktemp)
  jq --arg name "$name" 'del(.servers[$name])' "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"

  # If this was the current server, clear current
  current_server=$(jq -r '.current // empty' "$SERVERS_CONFIG" 2>/dev/null)
  if [ "$current_server" = "$name" ]; then
      jq '.current = null' "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"
      print_info "Cleared current server (was deleted server)"
  fi

  print_success "Server '$name' deleted successfully"
}

# :command.function
monk_servers_ping_command() {

  # src/servers_ping_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  name="${args[name]}"

  init_servers_config

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  # Get server info
  server_info=$(jq -r ".servers.\"$name\"" "$SERVERS_CONFIG" 2>/dev/null)
  if [ "$server_info" = "null" ]; then
      print_error "Server '$name' not found"
      print_info "Use 'monk servers list' to see available servers"
      exit 1
  fi

  hostname=$(echo "$server_info" | jq -r '.hostname')
  port=$(echo "$server_info" | jq -r '.port')
  protocol=$(echo "$server_info" | jq -r '.protocol')
  base_url="$protocol://$hostname:$port"

  print_info "Pinging server: $name ($base_url)"

  if ping_server_url "$base_url" 10; then
      print_success "Server is up and responding"

      # Update status in config
      timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
      temp_file=$(mktemp)
      jq --arg name "$name" \
         --arg timestamp "$timestamp" \
         '.servers[$name].last_ping = $timestamp | .servers[$name].status = "up"' \
         "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"
  else
      print_error "Server is down or not responding"

      # Update status in config
      timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
      temp_file=$(mktemp)
      jq --arg name "$name" \
         --arg timestamp "$timestamp" \
         '.servers[$name].last_ping = $timestamp | .servers[$name].status = "down"' \
         "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"
      exit 1
  fi
}

# :command.function
monk_servers_ping_all_command() {

  # src/servers_ping_all_command.sh
  # Check dependencies
  check_dependencies

  init_servers_config

  if ! command -v jq >/dev/null 2>&1; then
      print_error "jq is required for server management"
      exit 1
  fi

  echo
  print_info "Pinging All Servers"
  echo

  server_names=$(jq -r '.servers | keys[]' "$SERVERS_CONFIG" 2>/dev/null)

  if [ -z "$server_names" ]; then
      print_info "No servers configured"
      print_info "Use 'monk servers add <name> <hostname:port>' to add servers"
      exit 0
  fi

  up_count=0
  total_count=0

  # Use temp file to avoid subshell variable issues
  temp_results=$(mktemp)

  echo "$server_names" | while read -r name; do
      if [ -n "$name" ]; then
          echo "$((total_count + 1))" > "$temp_results.count"

          server_info=$(jq -r ".servers.\"$name\"" "$SERVERS_CONFIG")
          hostname=$(echo "$server_info" | jq -r '.hostname')
          port=$(echo "$server_info" | jq -r '.port')
          protocol=$(echo "$server_info" | jq -r '.protocol')
          base_url="$protocol://$hostname:$port"

          print_info "Pinging server: $name ($base_url)"

          if ping_server_url "$base_url" 5; then
              print_success "Server is up and responding"
              # Update status
              timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
              temp_file=$(mktemp)
              jq --arg name "$name" \
                 --arg timestamp "$timestamp" \
                 '.servers[$name].last_ping = $timestamp | .servers[$name].status = "up"' \
                 "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"

              # Count successful pings
              if [ -f "$temp_results.up" ]; then
                  up_count=$(cat "$temp_results.up")
              else
                  up_count=0
              fi
              echo "$((up_count + 1))" > "$temp_results.up"
          else
              print_error "Server is down or not responding"
              # Update status
              timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
              temp_file=$(mktemp)
              jq --arg name "$name" \
                 --arg timestamp "$timestamp" \
                 '.servers[$name].last_ping = $timestamp | .servers[$name].status = "down"' \
                 "$SERVERS_CONFIG" > "$temp_file" && mv "$temp_file" "$SERVERS_CONFIG"
          fi
      fi
  done

  # Read final counts
  if [ -f "$temp_results.count" ]; then
      total_count=$(cat "$temp_results.count")
  else
      total_count=0
  fi

  if [ -f "$temp_results.up" ]; then
      up_count=$(cat "$temp_results.up")
  else
      up_count=0
  fi

  # Clean up temp files
  rm -f "$temp_results" "$temp_results.count" "$temp_results.up"

  echo
  if [ "$up_count" -eq "$total_count" ] && [ "$total_count" -gt 0 ]; then
      print_success "All servers are up ($up_count/$total_count)"
  elif [ "$up_count" -eq 0 ] && [ "$total_count" -gt 0 ]; then
      print_error "All servers are down (0/$total_count)"
  elif [ "$total_count" -gt 0 ]; then
      print_info "$up_count/$total_count servers are up"
  fi
}

# :command.function
monk_tenant_create_command() {

  # src/tenant_create_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  tenant_name="${args[name]}"
  test_suffix="${args[test_suffix]}"
  host="${args[--host]}"

  print_info "Creating tenant: $tenant_name"

  db_user=$(whoami)

  # First create the actual PostgreSQL database
  if createdb "$tenant_name" -U "$db_user" 2>/dev/null; then
      print_success "Database '$tenant_name' created successfully"

      # Initialize tenant database with required schema tables
      if ! init_tenant_schema "$tenant_name" "$db_user"; then
          # Clean up the database we created
          dropdb "$tenant_name" -U "$db_user" 2>/dev/null || true
          exit 1
      fi
  else
      print_error "Failed to create database '$tenant_name'"
      exit 1
  fi

  # Then insert record into auth database tenants table
  sql_insert="INSERT INTO tenants (name, host"
  sql_values="VALUES ('$tenant_name', '$host'"

  if [ -n "$test_suffix" ]; then
      sql_insert="$sql_insert, test_suffix"
      sql_values="$sql_values, '$test_suffix'"
  fi

  sql_insert="$sql_insert) $sql_values);"

  if psql -U "$db_user" -d monk-api-auth -c "$sql_insert" >/dev/null 2>&1; then
      print_success "Tenant record created in auth database"
      if [ -n "$test_suffix" ]; then
          print_info "Tenant: $tenant_name (test: $test_suffix) on host: $host"
      else
          print_info "Tenant: $tenant_name on host: $host"
      fi
  else
      print_error "Failed to create tenant record in auth database"
      # Clean up the database we created
      dropdb "$tenant_name" -U "$db_user" 2>/dev/null || true
      exit 1
  fi
}

# :command.function
monk_tenant_delete_command() {

  # src/tenant_delete_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  tenant_name="${args[name]}"

  print_info "Deleting tenant: $tenant_name"

  db_user=$(whoami)

  # First remove record from auth database tenants table
  sql_delete="DELETE FROM tenants WHERE name = '$tenant_name';"

  if psql -U "$db_user" -d monk-api-auth -c "$sql_delete" >/dev/null 2>&1; then
      print_success "Tenant record removed from auth database"
  else
      print_error "Failed to remove tenant record from auth database"
      exit 1
  fi

  # Then drop the actual PostgreSQL database
  if dropdb "$tenant_name" -U "$db_user" 2>/dev/null; then
      print_success "Database '$tenant_name' deleted successfully"
  else
      print_error "Failed to delete database '$tenant_name'"
      exit 1
  fi
}

# :command.function
monk_tenant_init_command() {

  # src/tenant_init_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  tenant_name="${args[name]}"

  print_info "Re-initializing tenant database: $tenant_name"

  db_user=$(whoami)

  # Check if database exists
  if ! psql -U "$db_user" -lqt | cut -d'|' -f1 | grep -qw "$tenant_name" 2>/dev/null; then
      print_error "Database '$tenant_name' does not exist"
      print_info "Use 'monk tenant create $tenant_name' to create it first"
      exit 1
  fi

  # Drop and recreate database
  print_info "Dropping existing database..."
  if dropdb "$tenant_name" -U "$db_user" 2>/dev/null; then
      print_success "Database dropped"
  else
      print_error "Failed to drop database '$tenant_name'"
      exit 1
  fi

  print_info "Creating fresh database..."
  if createdb "$tenant_name" -U "$db_user" 2>/dev/null; then
      print_success "Database recreated"
  else
      print_error "Failed to recreate database '$tenant_name'"
      exit 1
  fi

  # Initialize with schema
  if ! init_tenant_schema "$tenant_name" "$db_user"; then
      exit 1
  fi

  print_success "Tenant database re-initialized successfully"
}

# :command.function
monk_tenant_list_command() {

  # src/tenant_list_command.sh
  # Check dependencies
  check_dependencies

  print_info "Listing all tenant databases"
  echo

  db_user=$(whoami)

  # Print header
  printf "%-30s %-20s %-8s %-8s %-8s %-8s %s\n" \
      "TENANT" \
      "HOST" \
      "STATUS" \
      "DB" \
      "SCHEMAS" \
      "COLUMNS" \
      "CREATED"
  echo "$(printf '%.s-' {1..100})"

  # Get tenant records from auth database
  tenants_query="SELECT name, host, test_suffix, is_active, created_at FROM tenants ORDER BY name, test_suffix;"

  # Use temporary file to avoid pipe subshell issues
  temp_file=$(mktemp)
  if psql -U "$db_user" -d monk-api-auth -t -c "$tenants_query" 2>/dev/null > "$temp_file"; then
      while IFS='|' read -r name host test_suffix is_active created_at; do
          # Clean up the fields (remove leading/trailing spaces)
          name=$(echo "$name" | xargs)
          host=$(echo "$host" | xargs)

          test_suffix=$(echo "$test_suffix" | xargs)
          is_active=$(echo "$is_active" | xargs)

          # Skip empty lines
          [ -z "$name" ] && continue

          # Build display name
          display_name="$name"
          if [ -n "$test_suffix" ] && [ "$test_suffix" != "" ]; then
              display_name="$name (test: $test_suffix)"
          fi

          # Get database stats if host is localhost
          schemas="?"
          columns="?"
          status="remote"

          if [ "$host" = "localhost" ]; then
              # Check if database exists locally
              if psql -U "$db_user" -lqt | cut -d'|' -f1 | grep -qw "$name" 2>/dev/null; then
                  status="local"
                  # Count tables in public schema
                  schema_count=$(psql -U "$db_user" -d "$name" -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';" 2>/dev/null || echo "0")
                  schemas=$(echo "$schema_count" | xargs)

                  # Count columns across all tables in public schema
                  column_count=$(psql -U "$db_user" -d "$name" -t -c "SELECT COUNT(*) FROM information_schema.columns WHERE table_schema = 'public';" 2>/dev/null || echo "0")
                  columns=$(echo "$column_count" | xargs)
              else
                  status="missing"
              fi
          fi

          # Format active status
          active_display="inactive"
          if [ "$is_active" = "t" ]; then
              active_display="active"
          fi

          # Format created date
          created_display=$(echo "$created_at" | cut -d'.' -f1)

          printf "%-30s %-20s %-8s %-8s %-8s %-8s %s\n" \
              "$display_name" \
              "$host" \
              "$active_display" \
              "$status" \
              "$schemas" \
              "$columns" \
              "$created_display"

      done < "$temp_file"
      rm -f "$temp_file"
  else
      rm -f "$temp_file"
      print_error "Failed to query tenants from auth database"
      exit 1
  fi
}

# :command.function
monk_tenant_use_command() {

  # src/tenant_use_command.sh
  # Check dependencies
  check_dependencies

  # Get arguments from bashly
  tenant_name="${args[name]}"

  print_info "Switching to tenant: $tenant_name"

  # Store tenant context in environment
  export CLI_TENANT="$tenant_name"

  # Optionally store in config file for persistence
  config_dir="$HOME/.monk"
  mkdir -p "$config_dir"
  echo "$tenant_name" > "$config_dir/current_tenant"

  print_success "Switched to tenant '$tenant_name'"
  print_info "Use 'monk auth login --domain $tenant_name' to authenticate"
}

# :command.function
monk_user_list_command() {

  # src/user_list_command.sh
  echo "# This file is located at 'src/user_list_command.sh'."
  echo "# It contains the implementation for the 'monk user list' command."
  echo "# The code you write here will be wrapped by a function named 'monk_user_list_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_user_get_command() {

  # src/user_get_command.sh
  echo "# This file is located at 'src/user_get_command.sh'."
  echo "# It contains the implementation for the 'monk user get' command."
  echo "# The code you write here will be wrapped by a function named 'monk_user_get_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_user_create_command() {

  # src/user_create_command.sh
  echo "# This file is located at 'src/user_create_command.sh'."
  echo "# It contains the implementation for the 'monk user create' command."
  echo "# The code you write here will be wrapped by a function named 'monk_user_create_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_user_update_command() {

  # src/user_update_command.sh
  echo "# This file is located at 'src/user_update_command.sh'."
  echo "# It contains the implementation for the 'monk user update' command."
  echo "# The code you write here will be wrapped by a function named 'monk_user_update_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_user_delete_command() {

  # src/user_delete_command.sh
  echo "# This file is located at 'src/user_delete_command.sh'."
  echo "# It contains the implementation for the 'monk user delete' command."
  echo "# The code you write here will be wrapped by a function named 'monk_user_delete_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_user_permissions_command() {

  # src/user_permissions_command.sh
  echo "# This file is located at 'src/user_permissions_command.sh'."
  echo "# It contains the implementation for the 'monk user permissions' command."
  echo "# The code you write here will be wrapped by a function named 'monk_user_permissions_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_root_status_command() {

  # src/root_status_command.sh
  echo "# This file is located at 'src/root_status_command.sh'."
  echo "# It contains the implementation for the 'monk root status' command."
  echo "# The code you write here will be wrapped by a function named 'monk_root_status_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_root_config_command() {

  # src/root_config_command.sh
  echo "# This file is located at 'src/root_config_command.sh'."
  echo "# It contains the implementation for the 'monk root config' command."
  echo "# The code you write here will be wrapped by a function named 'monk_root_config_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_root_domains_command() {

  # src/root_domains_command.sh
  echo "# This file is located at 'src/root_domains_command.sh'."
  echo "# It contains the implementation for the 'monk root domains' command."
  echo "# The code you write here will be wrapped by a function named 'monk_root_domains_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_root_cleanup_command() {

  # src/root_cleanup_command.sh
  echo "# This file is located at 'src/root_cleanup_command.sh'."
  echo "# It contains the implementation for the 'monk root cleanup' command."
  echo "# The code you write here will be wrapped by a function named 'monk_root_cleanup_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.function
monk_root_backup_command() {

  # src/root_backup_command.sh
  echo "# This file is located at 'src/root_backup_command.sh'."
  echo "# It contains the implementation for the 'monk root backup' command."
  echo "# The code you write here will be wrapped by a function named 'monk_root_backup_command()'."
  echo "# Feel free to edit this file; your changes will persist when regenerating."
  inspect_args

}

# :command.parse_requirements
parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        monk_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.environment_variables_filter

  env_var_names+=("CLI_BASE_URL")
  env_var_names+=("CLI_VERBOSE")
  env_var_names+=("JWT_TOKEN")

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    auth)
      action="auth"
      shift
      monk_auth_parse_requirements "$@"
      shift $#
      ;;

    data)
      action="data"
      shift
      monk_data_parse_requirements "$@"
      shift $#
      ;;

    meta)
      action="meta"
      shift
      monk_meta_parse_requirements "$@"
      shift $#
      ;;

    find)
      action="find"
      shift
      monk_find_parse_requirements "$@"
      shift $#
      ;;

    ping)
      action="ping"
      shift
      monk_ping_parse_requirements "$@"
      shift $#
      ;;

    test)
      action="test"
      shift
      monk_test_parse_requirements "$@"
      shift $#
      ;;

    pool)
      action="pool"
      shift
      monk_pool_parse_requirements "$@"
      shift $#
      ;;

    servers)
      action="servers"
      shift
      monk_servers_parse_requirements "$@"
      shift $#
      ;;

    tenant)
      action="tenant"
      shift
      monk_tenant_parse_requirements "$@"
      shift $#
      ;;

    user)
      action="user"
      shift
      monk_user_parse_requirements "$@"
      shift $#
      ;;

    root)
      action="root"
      shift
      monk_root_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    login)
      action="login"
      shift
      monk_auth_login_parse_requirements "$@"
      shift $#
      ;;

    logout)
      action="logout"
      shift
      monk_auth_logout_parse_requirements "$@"
      shift $#
      ;;

    status)
      action="status"
      shift
      monk_auth_status_parse_requirements "$@"
      shift $#
      ;;

    token)
      action="token"
      shift
      monk_auth_token_parse_requirements "$@"
      shift $#
      ;;

    info)
      action="info"
      shift
      monk_auth_info_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_auth_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_login_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_login_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth login"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --domain)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--domain']="$2"
          shift
          shift
        else
          printf "%s\n" "--domain requires an argument: --domain DOMAIN" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

  # :command.required_flags_filter
  if [[ -z ${args['--domain']+x} ]]; then
    printf "missing required flag: --domain DOMAIN\n" >&2
    exit 1
  fi

}

# :command.parse_requirements
monk_auth_logout_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_logout_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth logout"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_status_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_status_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth status"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_token_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_token_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth token"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_auth_info_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_auth_info_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="auth info"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_data_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    list)
      action="list"
      shift
      monk_data_list_parse_requirements "$@"
      shift $#
      ;;

    get)
      action="get"
      shift
      monk_data_get_parse_requirements "$@"
      shift $#
      ;;

    create)
      action="create"
      shift
      monk_data_create_parse_requirements "$@"
      shift $#
      ;;

    update)
      action="update"
      shift
      monk_data_update_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_data_delete_parse_requirements "$@"
      shift $#
      ;;

    export)
      action="export"
      shift
      monk_data_export_parse_requirements "$@"
      shift $#
      ;;

    import)
      action="import"
      shift
      monk_data_import_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_data_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_data_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data list SCHEMA\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_get_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_get_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data get"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data get SCHEMA ID\n" >&2

    exit 1
  fi

  if [[ -z ${args['id']+x} ]]; then
    printf "missing required argument: ID\nusage: monk data get SCHEMA ID\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data create SCHEMA\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_update_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data update"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data update SCHEMA ID\n" >&2

    exit 1
  fi

  if [[ -z ${args['id']+x} ]]; then
    printf "missing required argument: ID\nusage: monk data update SCHEMA ID\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data delete SCHEMA ID\n" >&2

    exit 1
  fi

  if [[ -z ${args['id']+x} ]]; then
    printf "missing required argument: ID\nusage: monk data delete SCHEMA ID\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_export_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_export_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data export"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['dir']+x} ]]; then
          args['dir']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data export SCHEMA DIR\n" >&2

    exit 1
  fi

  if [[ -z ${args['dir']+x} ]]; then
    printf "missing required argument: DIR\nusage: monk data export SCHEMA DIR\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_data_import_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_data_import_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="data import"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['dir']+x} ]]; then
          args['dir']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk data import SCHEMA DIR\n" >&2

    exit 1
  fi

  if [[ -z ${args['dir']+x} ]]; then
    printf "missing required argument: DIR\nusage: monk data import SCHEMA DIR\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_meta_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_meta_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    list)
      action="list"
      shift
      monk_meta_list_parse_requirements "$@"
      shift $#
      ;;

    get)
      action="get"
      shift
      monk_meta_get_parse_requirements "$@"
      shift $#
      ;;

    create)
      action="create"
      shift
      monk_meta_create_parse_requirements "$@"
      shift $#
      ;;

    update)
      action="update"
      shift
      monk_meta_update_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_meta_delete_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_meta_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_meta_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_meta_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="meta list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['type']+x} ]]; then
          args['type']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.default_assignments
  [[ -n ${args['type']:-} ]] || args['type']="schema"

}

# :command.parse_requirements
monk_meta_get_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_meta_get_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="meta get"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['type']+x} ]]; then
          args['type']=$1
          shift
        # :argument.case
        elif [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['type']+x} ]]; then
    printf "missing required argument: TYPE\nusage: monk meta get TYPE NAME\n" >&2

    exit 1
  fi

  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk meta get TYPE NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_meta_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_meta_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="meta create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['type']+x} ]]; then
          args['type']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['type']+x} ]]; then
    printf "missing required argument: TYPE\nusage: monk meta create TYPE\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_meta_update_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_meta_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="meta update"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['type']+x} ]]; then
          args['type']=$1
          shift
        # :argument.case
        elif [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['type']+x} ]]; then
    printf "missing required argument: TYPE\nusage: monk meta update TYPE NAME\n" >&2

    exit 1
  fi

  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk meta update TYPE NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_meta_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_meta_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="meta delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['type']+x} ]]; then
          args['type']=$1
          shift
        # :argument.case
        elif [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['type']+x} ]]; then
    printf "missing required argument: TYPE\nusage: monk meta delete TYPE NAME\n" >&2

    exit 1
  fi

  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk meta delete TYPE NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_find_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_find_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="find"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['schema']+x} ]]; then
          args['schema']=$1
          shift
        # :argument.case
        elif [[ -z ${args['filters']+x} ]]; then
          args['filters']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['schema']+x} ]]; then
    printf "missing required argument: SCHEMA\nusage: monk find SCHEMA [FILTERS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_ping_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_ping_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="ping"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --verbose | -v)

        # :flag.case_no_arg
        args['--verbose']=1
        shift
        ;;

      # :flag.case
      --jwt-token | -j)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--jwt-token']="$2"
          shift
          shift
        else
          printf "%s\n" "--jwt-token requires an argument: --jwt-token, -j TOKEN" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_test_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_test_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    all)
      action="all"
      shift
      monk_test_all_parse_requirements "$@"
      shift $#
      ;;

    git)
      action="git"
      shift
      monk_test_git_parse_requirements "$@"
      shift $#
      ;;

    diff)
      action="diff"
      shift
      monk_test_diff_parse_requirements "$@"
      shift $#
      ;;

    env)
      action="env"
      shift
      monk_test_env_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_test_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_test_all_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_test_all_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="test all"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['pattern']+x} ]]; then
          args['pattern']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
monk_test_git_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_test_git_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="test git"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['branch']+x} ]]; then
          args['branch']=$1
          shift
        # :argument.case
        elif [[ -z ${args['commit']+x} ]]; then
          args['commit']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['branch']+x} ]]; then
    printf "missing required argument: BRANCH\nusage: monk test git BRANCH [COMMIT]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_test_diff_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_test_diff_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="test diff"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['run1']+x} ]]; then
          args['run1']=$1
          shift
        # :argument.case
        elif [[ -z ${args['run2']+x} ]]; then
          args['run2']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['run1']+x} ]]; then
    printf "missing required argument: RUN1\nusage: monk test diff RUN1 RUN2\n" >&2

    exit 1
  fi

  if [[ -z ${args['run2']+x} ]]; then
    printf "missing required argument: RUN2\nusage: monk test diff RUN1 RUN2\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_test_env_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_test_env_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="test env"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['var_name']+x} ]]; then
          args['var_name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
monk_pool_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_pool_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    status)
      action="status"
      shift
      monk_pool_status_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      monk_pool_list_parse_requirements "$@"
      shift $#
      ;;

    cleanup)
      action="cleanup"
      shift
      monk_pool_cleanup_parse_requirements "$@"
      shift $#
      ;;

    cleanup-all)
      action="cleanup-all"
      shift
      monk_pool_cleanup_all_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_pool_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_pool_status_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_pool_status_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="pool status"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_pool_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_pool_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="pool list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_pool_cleanup_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_pool_cleanup_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="pool cleanup"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['hours']+x} ]]; then
          args['hours']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

}

# :command.parse_requirements
monk_pool_cleanup_all_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_pool_cleanup_all_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="pool cleanup-all"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_servers_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_servers_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    add)
      action="add"
      shift
      monk_servers_add_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      monk_servers_list_parse_requirements "$@"
      shift $#
      ;;

    current)
      action="current"
      shift
      monk_servers_current_parse_requirements "$@"
      shift $#
      ;;

    use)
      action="use"
      shift
      monk_servers_use_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_servers_delete_parse_requirements "$@"
      shift $#
      ;;

    ping)
      action="ping"
      shift
      monk_servers_ping_parse_requirements "$@"
      shift $#
      ;;

    ping-all)
      action="ping-all"
      shift
      monk_servers_ping_all_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_servers_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_servers_add_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_servers_add_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="servers add"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --description)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--description']="$2"
          shift
          shift
        else
          printf "%s\n" "--description requires an argument: --description DESCRIPTION" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        # :argument.case
        elif [[ -z ${args['endpoint']+x} ]]; then
          args['endpoint']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk servers add NAME ENDPOINT [OPTIONS]\n" >&2

    exit 1
  fi

  if [[ -z ${args['endpoint']+x} ]]; then
    printf "missing required argument: ENDPOINT\nusage: monk servers add NAME ENDPOINT [OPTIONS]\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_servers_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_servers_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="servers list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_servers_current_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_servers_current_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="servers current"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_servers_use_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_servers_use_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="servers use"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk servers use NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_servers_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_servers_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="servers delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk servers delete NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_servers_ping_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_servers_ping_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="servers ping"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk servers ping NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_servers_ping_all_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_servers_ping_all_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="servers ping-all"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_tenant_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    create)
      action="create"
      shift
      monk_tenant_create_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_tenant_delete_parse_requirements "$@"
      shift $#
      ;;

    init)
      action="init"
      shift
      monk_tenant_init_parse_requirements "$@"
      shift $#
      ;;

    list)
      action="list"
      shift
      monk_tenant_list_parse_requirements "$@"
      shift $#
      ;;

    use)
      action="use"
      shift
      monk_tenant_use_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_tenant_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_tenant_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --host)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--host']="$2"
          shift
          shift
        else
          printf "%s\n" "--host requires an argument: --host HOST" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        # :argument.case
        elif [[ -z ${args['test_suffix']+x} ]]; then
          args['test_suffix']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk tenant create NAME [TEST_SUFFIX] [OPTIONS]\n" >&2

    exit 1
  fi

  # :command.default_assignments
  [[ -n ${args['--host']:-} ]] || args['--host']="localhost"

}

# :command.parse_requirements
monk_tenant_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk tenant delete NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_tenant_init_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_init_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant init"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk tenant init NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_tenant_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_tenant_use_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_tenant_use_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="tenant use"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['name']+x} ]]; then
          args['name']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['name']+x} ]]; then
    printf "missing required argument: NAME\nusage: monk tenant use NAME\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_user_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_user_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    list)
      action="list"
      shift
      monk_user_list_parse_requirements "$@"
      shift $#
      ;;

    get)
      action="get"
      shift
      monk_user_get_parse_requirements "$@"
      shift $#
      ;;

    create)
      action="create"
      shift
      monk_user_create_parse_requirements "$@"
      shift $#
      ;;

    update)
      action="update"
      shift
      monk_user_update_parse_requirements "$@"
      shift $#
      ;;

    delete)
      action="delete"
      shift
      monk_user_delete_parse_requirements "$@"
      shift $#
      ;;

    permissions)
      action="permissions"
      shift
      monk_user_permissions_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_user_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_user_list_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_user_list_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="user list"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_user_get_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_user_get_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="user get"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['id']+x} ]]; then
    printf "missing required argument: ID\nusage: monk user get ID\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_user_create_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_user_create_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="user create"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_user_update_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_user_update_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="user update"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['id']+x} ]]; then
    printf "missing required argument: ID\nusage: monk user update ID\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_user_delete_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_user_delete_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="user delete"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['id']+x} ]]; then
    printf "missing required argument: ID\nusage: monk user delete ID\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_user_permissions_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_user_permissions_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="user permissions"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        # :argument.case
        if [[ -z ${args['id']+x} ]]; then
          args['id']=$1
          shift
        else
          printf "invalid argument: %s\n" "$key" >&2
          exit 1
        fi

        ;;

    esac
  done

  # :command.required_args_filter
  if [[ -z ${args['id']+x} ]]; then
    printf "missing required argument: ID\nusage: monk user permissions ID\n" >&2

    exit 1
  fi

}

# :command.parse_requirements
monk_root_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action=${1:-}

  case $action in
    -*) ;;

    status)
      action="status"
      shift
      monk_root_status_parse_requirements "$@"
      shift $#
      ;;

    config)
      action="config"
      shift
      monk_root_config_parse_requirements "$@"
      shift $#
      ;;

    domains)
      action="domains"
      shift
      monk_root_domains_parse_requirements "$@"
      shift $#
      ;;

    cleanup)
      action="cleanup"
      shift
      monk_root_cleanup_parse_requirements "$@"
      shift $#
      ;;

    backup)
      action="backup"
      shift
      monk_root_backup_parse_requirements "$@"
      shift $#
      ;;

    # :command.command_fallback
    "")
      monk_root_usage >&2
      exit 1
      ;;

    *)
      printf "invalid command: %s\n" "$action" >&2
      exit 1
      ;;

  esac

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_root_status_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_status_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root status"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_root_config_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_config_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root config"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_root_domains_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_domains_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root domains"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_root_cleanup_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_cleanup_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root cleanup"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.parse_requirements
monk_root_backup_parse_requirements() {
  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --help | -h)
        long_usage=yes
        monk_root_backup_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root backup"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="1.0.0"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "auth") monk_auth_command ;;
    "auth login") monk_auth_login_command ;;
    "auth logout") monk_auth_logout_command ;;
    "auth status") monk_auth_status_command ;;
    "auth token") monk_auth_token_command ;;
    "auth info") monk_auth_info_command ;;
    "data") monk_data_command ;;
    "data list") monk_data_list_command ;;
    "data get") monk_data_get_command ;;
    "data create") monk_data_create_command ;;
    "data update") monk_data_update_command ;;
    "data delete") monk_data_delete_command ;;
    "data export") monk_data_export_command ;;
    "data import") monk_data_import_command ;;
    "meta") monk_meta_command ;;
    "meta list") monk_meta_list_command ;;
    "meta get") monk_meta_get_command ;;
    "meta create") monk_meta_create_command ;;
    "meta update") monk_meta_update_command ;;
    "meta delete") monk_meta_delete_command ;;
    "find") monk_find_command ;;
    "ping") monk_ping_command ;;
    "test") monk_test_command ;;
    "test all") monk_test_all_command ;;
    "test git") monk_test_git_command ;;
    "test diff") monk_test_diff_command ;;
    "test env") monk_test_env_command ;;
    "pool") monk_pool_command ;;
    "pool status") monk_pool_status_command ;;
    "pool list") monk_pool_list_command ;;
    "pool cleanup") monk_pool_cleanup_command ;;
    "pool cleanup-all") monk_pool_cleanup_all_command ;;
    "servers") monk_servers_command ;;
    "servers add") monk_servers_add_command ;;
    "servers list") monk_servers_list_command ;;
    "servers current") monk_servers_current_command ;;
    "servers use") monk_servers_use_command ;;
    "servers delete") monk_servers_delete_command ;;
    "servers ping") monk_servers_ping_command ;;
    "servers ping-all") monk_servers_ping_all_command ;;
    "tenant") monk_tenant_command ;;
    "tenant create") monk_tenant_create_command ;;
    "tenant delete") monk_tenant_delete_command ;;
    "tenant init") monk_tenant_init_command ;;
    "tenant list") monk_tenant_list_command ;;
    "tenant use") monk_tenant_use_command ;;
    "user") monk_user_command ;;
    "user list") monk_user_list_command ;;
    "user get") monk_user_get_command ;;
    "user create") monk_user_create_command ;;
    "user update") monk_user_update_command ;;
    "user delete") monk_user_delete_command ;;
    "user permissions") monk_user_permissions_command ;;
    "root") monk_root_command ;;
    "root status") monk_root_status_command ;;
    "root config") monk_root_config_command ;;
    "root domains") monk_root_domains_command ;;
    "root cleanup") monk_root_cleanup_command ;;
    "root backup") monk_root_backup_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi
